// @ts-nocheck
// @generated by protobuf-ts 2.5.0 with parameter long_type_string
// @generated from protobuf file "evmos/incentives/v1/query.proto" (package "evmos.incentives.v1", syntax proto3)
// tslint:disable
import { ServiceType } from '@protobuf-ts/runtime-rpc'
import type { BinaryWriteOptions } from '@protobuf-ts/runtime'
import type { IBinaryWriter } from '@protobuf-ts/runtime'
import { WireType } from '@protobuf-ts/runtime'
import type { BinaryReadOptions } from '@protobuf-ts/runtime'
import type { IBinaryReader } from '@protobuf-ts/runtime'
import { UnknownFieldHandler } from '@protobuf-ts/runtime'
import type { PartialMessage } from '@protobuf-ts/runtime'
import { reflectionMergePartial } from '@protobuf-ts/runtime'
import { MESSAGE_TYPE } from '@protobuf-ts/runtime'
import { MessageType } from '@protobuf-ts/runtime'
import { Params } from './genesis'
import { DecCoin } from '../../../cosmos/base/v1beta1/coin'
import { GasMeter } from './incentives'
import { PageResponse } from '../../../cosmos/base/query/v1beta1/pagination'
import { Incentive } from './incentives'
import { PageRequest } from '../../../cosmos/base/query/v1beta1/pagination'
/**
 * QueryIncentivesRequest is the request type for the Query/Incentives RPC
 * method.
 *
 * @generated from protobuf messages evmos.incentives.v1.QueryIncentivesRequest
 */
export interface QueryIncentivesRequest {
  /**
   * pagination defines an optional pagination for the request.
   *
   * @generated from protobuf field: cosmos.base.query.v1beta1.PageRequest pagination = 1;
   */
  pagination?: PageRequest
}
/**
 * QueryIncentivesResponse is the response type for the Query/Incentives RPC
 * method.
 *
 * @generated from protobuf messages evmos.incentives.v1.QueryIncentivesResponse
 */
export interface QueryIncentivesResponse {
  /**
   * @generated from protobuf field: repeated evmos.incentives.v1.Incentive incentives = 1;
   */
  incentives: Incentive[]
  /**
   * pagination defines the pagination in the response.
   *
   * @generated from protobuf field: cosmos.base.query.v1beta1.PageResponse pagination = 2;
   */
  pagination?: PageResponse
}
/**
 * QueryIncentiveRequest is the request type for the Query/Incentive RPC method.
 *
 * @generated from protobuf messages evmos.incentives.v1.QueryIncentiveRequest
 */
export interface QueryIncentiveRequest {
  /**
   * contract identifier is the hex contract address of a contract
   *
   * @generated from protobuf field: string contract = 1;
   */
  contract: string
}
/**
 * QueryIncentiveResponse is the response type for the Query/Incentive RPC
 * method.
 *
 * @generated from protobuf messages evmos.incentives.v1.QueryIncentiveResponse
 */
export interface QueryIncentiveResponse {
  /**
   * @generated from protobuf field: evmos.incentives.v1.Incentive incentive = 1;
   */
  incentive?: Incentive
}
/**
 * QueryGasMetersRequest is the request type for the Query/Incentives RPC
 * method.
 *
 * @generated from protobuf messages evmos.incentives.v1.QueryGasMetersRequest
 */
export interface QueryGasMetersRequest {
  /**
   * contract is the hex contract address of a incentivized smart contract
   *
   * @generated from protobuf field: string contract = 1;
   */
  contract: string
  /**
   * pagination defines an optional pagination for the request.
   *
   * @generated from protobuf field: cosmos.base.query.v1beta1.PageRequest pagination = 2;
   */
  pagination?: PageRequest
}
/**
 * QueryGasMetersResponse is the response type for the Query/Incentives RPC
 * method.
 *
 * @generated from protobuf messages evmos.incentives.v1.QueryGasMetersResponse
 */
export interface QueryGasMetersResponse {
  /**
   * @generated from protobuf field: repeated evmos.incentives.v1.GasMeter gas_meters = 1;
   */
  gasMeters: GasMeter[]
  /**
   * pagination defines the pagination in the response.
   *
   * @generated from protobuf field: cosmos.base.query.v1beta1.PageResponse pagination = 2;
   */
  pagination?: PageResponse
}
/**
 * QueryGasMeterRequest is the request type for the Query/Incentive RPC method.
 *
 * @generated from protobuf messages evmos.incentives.v1.QueryGasMeterRequest
 */
export interface QueryGasMeterRequest {
  /**
   * contract identifier is the hex contract address of a contract
   *
   * @generated from protobuf field: string contract = 1;
   */
  contract: string
  /**
   * participant identifier is the hex address of a user
   *
   * @generated from protobuf field: string participant = 2;
   */
  participant: string
}
/**
 * QueryGasMeterResponse is the response type for the Query/Incentive RPC
 * method.
 *
 * @generated from protobuf messages evmos.incentives.v1.QueryGasMeterResponse
 */
export interface QueryGasMeterResponse {
  /**
   * @generated from protobuf field: uint64 gas_meter = 1;
   */
  gasMeter: string
}
/**
 * QueryAllocationMetersRequest is the request type for the
 * Query/AllocationMeters RPC method.
 *
 * @generated from protobuf messages evmos.incentives.v1.QueryAllocationMetersRequest
 */
export interface QueryAllocationMetersRequest {
  /**
   * pagination defines an optional pagination for the request.
   *
   * @generated from protobuf field: cosmos.base.query.v1beta1.PageRequest pagination = 1;
   */
  pagination?: PageRequest
}
/**
 * QueryAllocationMetersResponse is the response type for the
 * Query/AllocationMeters RPC method.
 *
 * @generated from protobuf messages evmos.incentives.v1.QueryAllocationMetersResponse
 */
export interface QueryAllocationMetersResponse {
  /**
   * @generated from protobuf field: repeated cosmos.base.v1beta1.DecCoin allocation_meters = 1;
   */
  allocationMeters: DecCoin[]
  /**
   * pagination defines the pagination in the response.
   *
   * @generated from protobuf field: cosmos.base.query.v1beta1.PageResponse pagination = 2;
   */
  pagination?: PageResponse
}
/**
 * QueryAllocationMeterRequest is the request type for the Query/AllocationMeter
 * RPC method.
 *
 * @generated from protobuf messages evmos.incentives.v1.QueryAllocationMeterRequest
 */
export interface QueryAllocationMeterRequest {
  /**
   * denom is the coin denom to query an allocation meter for.
   *
   * @generated from protobuf field: string denom = 1;
   */
  denom: string
}
/**
 * QueryAllocationMeterResponse is the response type for the
 * Query/AllocationMeter RPC method.
 *
 * @generated from protobuf messages evmos.incentives.v1.QueryAllocationMeterResponse
 */
export interface QueryAllocationMeterResponse {
  /**
   * @generated from protobuf field: cosmos.base.v1beta1.DecCoin allocation_meter = 1;
   */
  allocationMeter?: DecCoin
}
/**
 * QueryParamsRequest is the request type for the Query/Params RPC method.
 *
 * @generated from protobuf messages evmos.incentives.v1.QueryParamsRequest
 */
export interface QueryParamsRequest {}
/**
 * QueryParamsResponse is the response type for the Query/Params RPC
 * method.
 *
 * @generated from protobuf messages evmos.incentives.v1.QueryParamsResponse
 */
export interface QueryParamsResponse {
  /**
   * @generated from protobuf field: evmos.incentives.v1.Params params = 1;
   */
  params?: Params
}
// @generated messages type with reflection information, may provide speed optimized methods
class QueryIncentivesRequest$Type extends MessageType<QueryIncentivesRequest> {
  constructor() {
    super('evmos.incentives.v1.QueryIncentivesRequest', [
      { no: 1, name: 'pagination', kind: 'message', T: () => PageRequest },
    ])
  }
  create(
    value?: PartialMessage<QueryIncentivesRequest>,
  ): QueryIncentivesRequest {
    const message = {}
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    })
    if (value !== undefined)
      reflectionMergePartial<QueryIncentivesRequest>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: QueryIncentivesRequest,
  ): QueryIncentivesRequest {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* cosmos.base.query.v1beta1.PageRequest pagination */ 1:
          message.pagination = PageRequest.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.pagination,
          )
          break
        default:
          let u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: QueryIncentivesRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* cosmos.base.query.v1beta1.PageRequest pagination = 1; */
    if (message.pagination)
      PageRequest.internalBinaryWrite(
        message.pagination,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join()
    let u = options.writeUnknownFields
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      )
    return writer
  }
}
/**
 * @generated MessageType for protobuf messages evmos.incentives.v1.QueryIncentivesRequest
 */
export const QueryIncentivesRequest = new QueryIncentivesRequest$Type()
// @generated messages type with reflection information, may provide speed optimized methods
class QueryIncentivesResponse$Type extends MessageType<QueryIncentivesResponse> {
  constructor() {
    super('evmos.incentives.v1.QueryIncentivesResponse', [
      {
        no: 1,
        name: 'incentives',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => Incentive,
        options: { 'gogoproto.nullable': false },
      },
      { no: 2, name: 'pagination', kind: 'message', T: () => PageResponse },
    ])
  }
  create(
    value?: PartialMessage<QueryIncentivesResponse>,
  ): QueryIncentivesResponse {
    const message = { incentives: [] }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    })
    if (value !== undefined)
      reflectionMergePartial<QueryIncentivesResponse>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: QueryIncentivesResponse,
  ): QueryIncentivesResponse {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* repeated evmos.incentives.v1.Incentive incentives */ 1:
          message.incentives.push(
            Incentive.internalBinaryRead(reader, reader.uint32(), options),
          )
          break
        case /* cosmos.base.query.v1beta1.PageResponse pagination */ 2:
          message.pagination = PageResponse.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.pagination,
          )
          break
        default:
          let u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: QueryIncentivesResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated evmos.incentives.v1.Incentive incentives = 1; */
    for (let i = 0; i < message.incentives.length; i++)
      Incentive.internalBinaryWrite(
        message.incentives[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join()
    /* cosmos.base.query.v1beta1.PageResponse pagination = 2; */
    if (message.pagination)
      PageResponse.internalBinaryWrite(
        message.pagination,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join()
    let u = options.writeUnknownFields
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      )
    return writer
  }
}
/**
 * @generated MessageType for protobuf messages evmos.incentives.v1.QueryIncentivesResponse
 */
export const QueryIncentivesResponse = new QueryIncentivesResponse$Type()
// @generated messages type with reflection information, may provide speed optimized methods
class QueryIncentiveRequest$Type extends MessageType<QueryIncentiveRequest> {
  constructor() {
    super('evmos.incentives.v1.QueryIncentiveRequest', [
      { no: 1, name: 'contract', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
    ])
  }
  create(value?: PartialMessage<QueryIncentiveRequest>): QueryIncentiveRequest {
    const message = { contract: '' }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    })
    if (value !== undefined)
      reflectionMergePartial<QueryIncentiveRequest>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: QueryIncentiveRequest,
  ): QueryIncentiveRequest {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string contract */ 1:
          message.contract = reader.string()
          break
        default:
          let u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: QueryIncentiveRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string contract = 1; */
    if (message.contract !== '')
      writer.tag(1, WireType.LengthDelimited).string(message.contract)
    let u = options.writeUnknownFields
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      )
    return writer
  }
}
/**
 * @generated MessageType for protobuf messages evmos.incentives.v1.QueryIncentiveRequest
 */
export const QueryIncentiveRequest = new QueryIncentiveRequest$Type()
// @generated messages type with reflection information, may provide speed optimized methods
class QueryIncentiveResponse$Type extends MessageType<QueryIncentiveResponse> {
  constructor() {
    super('evmos.incentives.v1.QueryIncentiveResponse', [
      {
        no: 1,
        name: 'incentive',
        kind: 'message',
        T: () => Incentive,
        options: { 'gogoproto.nullable': false },
      },
    ])
  }
  create(
    value?: PartialMessage<QueryIncentiveResponse>,
  ): QueryIncentiveResponse {
    const message = {}
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    })
    if (value !== undefined)
      reflectionMergePartial<QueryIncentiveResponse>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: QueryIncentiveResponse,
  ): QueryIncentiveResponse {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* evmos.incentives.v1.Incentive incentive */ 1:
          message.incentive = Incentive.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.incentive,
          )
          break
        default:
          let u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: QueryIncentiveResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* evmos.incentives.v1.Incentive incentive = 1; */
    if (message.incentive)
      Incentive.internalBinaryWrite(
        message.incentive,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join()
    let u = options.writeUnknownFields
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      )
    return writer
  }
}
/**
 * @generated MessageType for protobuf messages evmos.incentives.v1.QueryIncentiveResponse
 */
export const QueryIncentiveResponse = new QueryIncentiveResponse$Type()
// @generated messages type with reflection information, may provide speed optimized methods
class QueryGasMetersRequest$Type extends MessageType<QueryGasMetersRequest> {
  constructor() {
    super('evmos.incentives.v1.QueryGasMetersRequest', [
      { no: 1, name: 'contract', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: 'pagination', kind: 'message', T: () => PageRequest },
    ])
  }
  create(value?: PartialMessage<QueryGasMetersRequest>): QueryGasMetersRequest {
    const message = { contract: '' }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    })
    if (value !== undefined)
      reflectionMergePartial<QueryGasMetersRequest>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: QueryGasMetersRequest,
  ): QueryGasMetersRequest {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string contract */ 1:
          message.contract = reader.string()
          break
        case /* cosmos.base.query.v1beta1.PageRequest pagination */ 2:
          message.pagination = PageRequest.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.pagination,
          )
          break
        default:
          let u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: QueryGasMetersRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string contract = 1; */
    if (message.contract !== '')
      writer.tag(1, WireType.LengthDelimited).string(message.contract)
    /* cosmos.base.query.v1beta1.PageRequest pagination = 2; */
    if (message.pagination)
      PageRequest.internalBinaryWrite(
        message.pagination,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join()
    let u = options.writeUnknownFields
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      )
    return writer
  }
}
/**
 * @generated MessageType for protobuf messages evmos.incentives.v1.QueryGasMetersRequest
 */
export const QueryGasMetersRequest = new QueryGasMetersRequest$Type()
// @generated messages type with reflection information, may provide speed optimized methods
class QueryGasMetersResponse$Type extends MessageType<QueryGasMetersResponse> {
  constructor() {
    super('evmos.incentives.v1.QueryGasMetersResponse', [
      {
        no: 1,
        name: 'gas_meters',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => GasMeter,
        options: { 'gogoproto.nullable': false },
      },
      { no: 2, name: 'pagination', kind: 'message', T: () => PageResponse },
    ])
  }
  create(
    value?: PartialMessage<QueryGasMetersResponse>,
  ): QueryGasMetersResponse {
    const message = { gasMeters: [] }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    })
    if (value !== undefined)
      reflectionMergePartial<QueryGasMetersResponse>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: QueryGasMetersResponse,
  ): QueryGasMetersResponse {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* repeated evmos.incentives.v1.GasMeter gas_meters */ 1:
          message.gasMeters.push(
            GasMeter.internalBinaryRead(reader, reader.uint32(), options),
          )
          break
        case /* cosmos.base.query.v1beta1.PageResponse pagination */ 2:
          message.pagination = PageResponse.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.pagination,
          )
          break
        default:
          let u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: QueryGasMetersResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated evmos.incentives.v1.GasMeter gas_meters = 1; */
    for (let i = 0; i < message.gasMeters.length; i++)
      GasMeter.internalBinaryWrite(
        message.gasMeters[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join()
    /* cosmos.base.query.v1beta1.PageResponse pagination = 2; */
    if (message.pagination)
      PageResponse.internalBinaryWrite(
        message.pagination,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join()
    let u = options.writeUnknownFields
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      )
    return writer
  }
}
/**
 * @generated MessageType for protobuf messages evmos.incentives.v1.QueryGasMetersResponse
 */
export const QueryGasMetersResponse = new QueryGasMetersResponse$Type()
// @generated messages type with reflection information, may provide speed optimized methods
class QueryGasMeterRequest$Type extends MessageType<QueryGasMeterRequest> {
  constructor() {
    super('evmos.incentives.v1.QueryGasMeterRequest', [
      { no: 1, name: 'contract', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      {
        no: 2,
        name: 'participant',
        kind: 'scalar',
        T: 9 /*ScalarType.STRING*/,
      },
    ])
  }
  create(value?: PartialMessage<QueryGasMeterRequest>): QueryGasMeterRequest {
    const message = { contract: '', participant: '' }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    })
    if (value !== undefined)
      reflectionMergePartial<QueryGasMeterRequest>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: QueryGasMeterRequest,
  ): QueryGasMeterRequest {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string contract */ 1:
          message.contract = reader.string()
          break
        case /* string participant */ 2:
          message.participant = reader.string()
          break
        default:
          let u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: QueryGasMeterRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string contract = 1; */
    if (message.contract !== '')
      writer.tag(1, WireType.LengthDelimited).string(message.contract)
    /* string participant = 2; */
    if (message.participant !== '')
      writer.tag(2, WireType.LengthDelimited).string(message.participant)
    let u = options.writeUnknownFields
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      )
    return writer
  }
}
/**
 * @generated MessageType for protobuf messages evmos.incentives.v1.QueryGasMeterRequest
 */
export const QueryGasMeterRequest = new QueryGasMeterRequest$Type()
// @generated messages type with reflection information, may provide speed optimized methods
class QueryGasMeterResponse$Type extends MessageType<QueryGasMeterResponse> {
  constructor() {
    super('evmos.incentives.v1.QueryGasMeterResponse', [
      { no: 1, name: 'gas_meter', kind: 'scalar', T: 4 /*ScalarType.UINT64*/ },
    ])
  }
  create(value?: PartialMessage<QueryGasMeterResponse>): QueryGasMeterResponse {
    const message = { gasMeter: '0' }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    })
    if (value !== undefined)
      reflectionMergePartial<QueryGasMeterResponse>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: QueryGasMeterResponse,
  ): QueryGasMeterResponse {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* uint64 gas_meter */ 1:
          message.gasMeter = reader.uint64().toString()
          break
        default:
          let u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: QueryGasMeterResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* uint64 gas_meter = 1; */
    if (message.gasMeter !== '0')
      writer.tag(1, WireType.Varint).uint64(message.gasMeter)
    let u = options.writeUnknownFields
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      )
    return writer
  }
}
/**
 * @generated MessageType for protobuf messages evmos.incentives.v1.QueryGasMeterResponse
 */
export const QueryGasMeterResponse = new QueryGasMeterResponse$Type()
// @generated messages type with reflection information, may provide speed optimized methods
class QueryAllocationMetersRequest$Type extends MessageType<QueryAllocationMetersRequest> {
  constructor() {
    super('evmos.incentives.v1.QueryAllocationMetersRequest', [
      { no: 1, name: 'pagination', kind: 'message', T: () => PageRequest },
    ])
  }
  create(
    value?: PartialMessage<QueryAllocationMetersRequest>,
  ): QueryAllocationMetersRequest {
    const message = {}
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    })
    if (value !== undefined)
      reflectionMergePartial<QueryAllocationMetersRequest>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: QueryAllocationMetersRequest,
  ): QueryAllocationMetersRequest {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* cosmos.base.query.v1beta1.PageRequest pagination */ 1:
          message.pagination = PageRequest.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.pagination,
          )
          break
        default:
          let u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: QueryAllocationMetersRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* cosmos.base.query.v1beta1.PageRequest pagination = 1; */
    if (message.pagination)
      PageRequest.internalBinaryWrite(
        message.pagination,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join()
    let u = options.writeUnknownFields
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      )
    return writer
  }
}
/**
 * @generated MessageType for protobuf messages evmos.incentives.v1.QueryAllocationMetersRequest
 */
export const QueryAllocationMetersRequest =
  new QueryAllocationMetersRequest$Type()
// @generated messages type with reflection information, may provide speed optimized methods
class QueryAllocationMetersResponse$Type extends MessageType<QueryAllocationMetersResponse> {
  constructor() {
    super('evmos.incentives.v1.QueryAllocationMetersResponse', [
      {
        no: 1,
        name: 'allocation_meters',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => DecCoin,
        options: {
          'gogoproto.nullable': false,
          'gogoproto.castrepeated':
            'github.com/cosmos/cosmos-sdk/types.DecCoins',
        },
      },
      { no: 2, name: 'pagination', kind: 'message', T: () => PageResponse },
    ])
  }
  create(
    value?: PartialMessage<QueryAllocationMetersResponse>,
  ): QueryAllocationMetersResponse {
    const message = { allocationMeters: [] }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    })
    if (value !== undefined)
      reflectionMergePartial<QueryAllocationMetersResponse>(
        this,
        message,
        value,
      )
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: QueryAllocationMetersResponse,
  ): QueryAllocationMetersResponse {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* repeated cosmos.base.v1beta1.DecCoin allocation_meters */ 1:
          message.allocationMeters.push(
            DecCoin.internalBinaryRead(reader, reader.uint32(), options),
          )
          break
        case /* cosmos.base.query.v1beta1.PageResponse pagination */ 2:
          message.pagination = PageResponse.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.pagination,
          )
          break
        default:
          let u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: QueryAllocationMetersResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated cosmos.base.v1beta1.DecCoin allocation_meters = 1; */
    for (let i = 0; i < message.allocationMeters.length; i++)
      DecCoin.internalBinaryWrite(
        message.allocationMeters[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join()
    /* cosmos.base.query.v1beta1.PageResponse pagination = 2; */
    if (message.pagination)
      PageResponse.internalBinaryWrite(
        message.pagination,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join()
    let u = options.writeUnknownFields
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      )
    return writer
  }
}
/**
 * @generated MessageType for protobuf messages evmos.incentives.v1.QueryAllocationMetersResponse
 */
export const QueryAllocationMetersResponse =
  new QueryAllocationMetersResponse$Type()
// @generated messages type with reflection information, may provide speed optimized methods
class QueryAllocationMeterRequest$Type extends MessageType<QueryAllocationMeterRequest> {
  constructor() {
    super('evmos.incentives.v1.QueryAllocationMeterRequest', [
      { no: 1, name: 'denom', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
    ])
  }
  create(
    value?: PartialMessage<QueryAllocationMeterRequest>,
  ): QueryAllocationMeterRequest {
    const message = { denom: '' }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    })
    if (value !== undefined)
      reflectionMergePartial<QueryAllocationMeterRequest>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: QueryAllocationMeterRequest,
  ): QueryAllocationMeterRequest {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string denom */ 1:
          message.denom = reader.string()
          break
        default:
          let u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: QueryAllocationMeterRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string denom = 1; */
    if (message.denom !== '')
      writer.tag(1, WireType.LengthDelimited).string(message.denom)
    let u = options.writeUnknownFields
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      )
    return writer
  }
}
/**
 * @generated MessageType for protobuf messages evmos.incentives.v1.QueryAllocationMeterRequest
 */
export const QueryAllocationMeterRequest =
  new QueryAllocationMeterRequest$Type()
// @generated messages type with reflection information, may provide speed optimized methods
class QueryAllocationMeterResponse$Type extends MessageType<QueryAllocationMeterResponse> {
  constructor() {
    super('evmos.incentives.v1.QueryAllocationMeterResponse', [
      {
        no: 1,
        name: 'allocation_meter',
        kind: 'message',
        T: () => DecCoin,
        options: {
          'gogoproto.nullable': false,
          'gogoproto.castrepeated':
            'github.com/cosmos/cosmos-sdk/types.DecCoins',
        },
      },
    ])
  }
  create(
    value?: PartialMessage<QueryAllocationMeterResponse>,
  ): QueryAllocationMeterResponse {
    const message = {}
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    })
    if (value !== undefined)
      reflectionMergePartial<QueryAllocationMeterResponse>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: QueryAllocationMeterResponse,
  ): QueryAllocationMeterResponse {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* cosmos.base.v1beta1.DecCoin allocation_meter */ 1:
          message.allocationMeter = DecCoin.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.allocationMeter,
          )
          break
        default:
          let u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: QueryAllocationMeterResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* cosmos.base.v1beta1.DecCoin allocation_meter = 1; */
    if (message.allocationMeter)
      DecCoin.internalBinaryWrite(
        message.allocationMeter,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join()
    let u = options.writeUnknownFields
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      )
    return writer
  }
}
/**
 * @generated MessageType for protobuf messages evmos.incentives.v1.QueryAllocationMeterResponse
 */
export const QueryAllocationMeterResponse =
  new QueryAllocationMeterResponse$Type()
// @generated messages type with reflection information, may provide speed optimized methods
class QueryParamsRequest$Type extends MessageType<QueryParamsRequest> {
  constructor() {
    super('evmos.incentives.v1.QueryParamsRequest', [])
  }
  create(value?: PartialMessage<QueryParamsRequest>): QueryParamsRequest {
    const message = {}
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    })
    if (value !== undefined)
      reflectionMergePartial<QueryParamsRequest>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: QueryParamsRequest,
  ): QueryParamsRequest {
    return target ?? this.create()
  }
  internalBinaryWrite(
    message: QueryParamsRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    let u = options.writeUnknownFields
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      )
    return writer
  }
}
/**
 * @generated MessageType for protobuf messages evmos.incentives.v1.QueryParamsRequest
 */
export const QueryParamsRequest = new QueryParamsRequest$Type()
// @generated messages type with reflection information, may provide speed optimized methods
class QueryParamsResponse$Type extends MessageType<QueryParamsResponse> {
  constructor() {
    super('evmos.incentives.v1.QueryParamsResponse', [
      {
        no: 1,
        name: 'params',
        kind: 'message',
        T: () => Params,
        options: { 'gogoproto.nullable': false },
      },
    ])
  }
  create(value?: PartialMessage<QueryParamsResponse>): QueryParamsResponse {
    const message = {}
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    })
    if (value !== undefined)
      reflectionMergePartial<QueryParamsResponse>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: QueryParamsResponse,
  ): QueryParamsResponse {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* evmos.incentives.v1.Params params */ 1:
          message.params = Params.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.params,
          )
          break
        default:
          let u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: QueryParamsResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* evmos.incentives.v1.Params params = 1; */
    if (message.params)
      Params.internalBinaryWrite(
        message.params,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join()
    let u = options.writeUnknownFields
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      )
    return writer
  }
}
/**
 * @generated MessageType for protobuf messages evmos.incentives.v1.QueryParamsResponse
 */
export const QueryParamsResponse = new QueryParamsResponse$Type()
/**
 * @generated ServiceType for protobuf service evmos.incentives.v1.Query
 */
export const Query = new ServiceType('evmos.incentives.v1.Query', [
  {
    name: 'Incentives',
    options: { 'google.api.http': { get: '/evmos/incentives/v1/incentives' } },
    I: QueryIncentivesRequest,
    O: QueryIncentivesResponse,
  },
  {
    name: 'Incentive',
    options: {
      'google.api.http': { get: '/evmos/incentives/v1/incentives/{contract}' },
    },
    I: QueryIncentiveRequest,
    O: QueryIncentiveResponse,
  },
  {
    name: 'GasMeters',
    options: {
      'google.api.http': { get: '/evmos/incentives/v1/gas_meters/{contract}' },
    },
    I: QueryGasMetersRequest,
    O: QueryGasMetersResponse,
  },
  {
    name: 'GasMeter',
    options: {
      'google.api.http': {
        get: '/evmos/incentives/v1/gas_meters/{contract}/{participant}',
      },
    },
    I: QueryGasMeterRequest,
    O: QueryGasMeterResponse,
  },
  {
    name: 'AllocationMeters',
    options: {
      'google.api.http': { get: '/evmos/incentives/v1/allocation_meters' },
    },
    I: QueryAllocationMetersRequest,
    O: QueryAllocationMetersResponse,
  },
  {
    name: 'AllocationMeter',
    options: {
      'google.api.http': {
        get: '/evmos/incentives/v1/allocation_meters/{denom}',
      },
    },
    I: QueryAllocationMeterRequest,
    O: QueryAllocationMeterResponse,
  },
  {
    name: 'Params',
    options: { 'google.api.http': { get: '/evmos/incentives/v1/params' } },
    I: QueryParamsRequest,
    O: QueryParamsResponse,
  },
])
