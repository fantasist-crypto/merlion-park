// @ts-nocheck
// @generated by protobuf-ts 2.5.0 with parameter long_type_string
// @generated from protobuf file "evmos/erc20/v1/erc20.proto" (package "evmos.erc20.v1", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from '@protobuf-ts/runtime'
import type { IBinaryWriter } from '@protobuf-ts/runtime'
import { WireType } from '@protobuf-ts/runtime'
import type { BinaryReadOptions } from '@protobuf-ts/runtime'
import type { IBinaryReader } from '@protobuf-ts/runtime'
import { UnknownFieldHandler } from '@protobuf-ts/runtime'
import type { PartialMessage } from '@protobuf-ts/runtime'
import { reflectionMergePartial } from '@protobuf-ts/runtime'
import { MESSAGE_TYPE } from '@protobuf-ts/runtime'
import { MessageType } from '@protobuf-ts/runtime'
import { Metadata } from '../../../cosmos/bank/v1beta1/bank'
/**
 * TokenPair defines an instance that records pairing consisting of a Cosmos
 * native Coin and an ERC20 token address.
 *
 * @generated from protobuf messages evmos.erc20.v1.TokenPair
 */
export interface TokenPair {
  /**
   * address of ERC20 contract token
   *
   * @generated from protobuf field: string erc20_address = 1;
   */
  erc20Address: string
  /**
   * cosmos base denomination to be mapped to
   *
   * @generated from protobuf field: string denom = 2;
   */
  denom: string
  /**
   * shows token mapping enable status
   *
   * @generated from protobuf field: bool enabled = 3;
   */
  enabled: boolean
  /**
   * ERC20 owner address ENUM (0 invalid, 1 ModuleAccount, 2 external address)
   *
   * @generated from protobuf field: evmos.erc20.v1.Owner contract_owner = 4;
   */
  contractOwner: Owner
}
/**
 * RegisterCoinProposal is a gov Content type to register a token pair
 *
 * @generated from protobuf messages evmos.erc20.v1.RegisterCoinProposal
 */
export interface RegisterCoinProposal {
  /**
   * title of the proposal
   *
   * @generated from protobuf field: string title = 1;
   */
  title: string
  /**
   * proposal description
   *
   * @generated from protobuf field: string description = 2;
   */
  description: string
  /**
   * token pair of Cosmos native denom and ERC20 token address
   *
   * @generated from protobuf field: cosmos.bank.v1beta1.Metadata metadata = 3;
   */
  metadata?: Metadata
}
/**
 * RegisterCoinProposal is a gov Content type to register a token pair
 *
 * @generated from protobuf messages evmos.erc20.v1.RegisterERC20Proposal
 */
export interface RegisterERC20Proposal {
  /**
   * title of the proposal
   *
   * @generated from protobuf field: string title = 1;
   */
  title: string
  /**
   * proposal description
   *
   * @generated from protobuf field: string description = 2;
   */
  description: string
  /**
   * contract address of ERC20 token
   *
   * @generated from protobuf field: string erc20address = 3 [json_name = "erc20address"];
   */
  erc20Address: string
}
/**
 * ToggleTokenRelayProposal is a gov Content type to toggle
 * the internal relaying of a token pair.
 *
 * @generated from protobuf messages evmos.erc20.v1.ToggleTokenRelayProposal
 */
export interface ToggleTokenRelayProposal {
  /**
   * title of the proposal
   *
   * @generated from protobuf field: string title = 1;
   */
  title: string
  /**
   * proposal description
   *
   * @generated from protobuf field: string description = 2;
   */
  description: string
  /**
   * token identifier can be either the hex contract address of the ERC20 or the
   * Cosmos base denomination
   *
   * @generated from protobuf field: string token = 3;
   */
  token: string
}
/**
 * UpdateTokenPairERC20Proposal is a gov Content type to update a token pair's
 * ERC20 contract address.
 *
 * @generated from protobuf messages evmos.erc20.v1.UpdateTokenPairERC20Proposal
 */
export interface UpdateTokenPairERC20Proposal {
  /**
   * title of the proposal
   *
   * @generated from protobuf field: string title = 1;
   */
  title: string
  /**
   * proposal description
   *
   * @generated from protobuf field: string description = 2;
   */
  description: string
  /**
   * contract address of ERC20 token
   *
   * @generated from protobuf field: string erc20_address = 3;
   */
  erc20Address: string
  /**
   * new address of ERC20 token contract
   *
   * @generated from protobuf field: string new_erc20_address = 4;
   */
  newErc20Address: string
}
/**
 * Owner enumerates the ownership of a ERC20 contract.
 *
 * @generated from protobuf enum evmos.erc20.v1.Owner
 */
export enum Owner {
  /**
   * OWNER_UNSPECIFIED defines an invalid/undefined owner.
   *
   * @generated from protobuf enum value: OWNER_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,
  /**
   * OWNER_MODULE erc20 is owned by the erc20 module account.
   *
   * @generated from protobuf enum value: OWNER_MODULE = 1;
   */
  MODULE = 1,
  /**
   * EXTERNAL erc20 is owned by an external account.
   *
   * @generated from protobuf enum value: OWNER_EXTERNAL = 2;
   */
  EXTERNAL = 2,
}
// @generated messages type with reflection information, may provide speed optimized methods
class TokenPair$Type extends MessageType<TokenPair> {
  constructor() {
    super(
      'evmos.erc20.v1.TokenPair',
      [
        {
          no: 1,
          name: 'erc20_address',
          kind: 'scalar',
          T: 9 /*ScalarType.STRING*/,
        },
        { no: 2, name: 'denom', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
        { no: 3, name: 'enabled', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
        {
          no: 4,
          name: 'contract_owner',
          kind: 'enum',
          T: () => ['evmos.erc20.v1.Owner', Owner, 'OWNER_'],
        },
      ],
      { 'gogoproto.equal': true },
    )
  }
  create(value?: PartialMessage<TokenPair>): TokenPair {
    const message = {
      erc20Address: '',
      denom: '',
      enabled: false,
      contractOwner: 0,
    }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    })
    if (value !== undefined)
      reflectionMergePartial<TokenPair>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: TokenPair,
  ): TokenPair {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string erc20_address */ 1:
          message.erc20Address = reader.string()
          break
        case /* string denom */ 2:
          message.denom = reader.string()
          break
        case /* bool enabled */ 3:
          message.enabled = reader.bool()
          break
        case /* evmos.erc20.v1.Owner contract_owner */ 4:
          message.contractOwner = reader.int32()
          break
        default:
          let u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: TokenPair,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string erc20_address = 1; */
    if (message.erc20Address !== '')
      writer.tag(1, WireType.LengthDelimited).string(message.erc20Address)
    /* string denom = 2; */
    if (message.denom !== '')
      writer.tag(2, WireType.LengthDelimited).string(message.denom)
    /* bool enabled = 3; */
    if (message.enabled !== false)
      writer.tag(3, WireType.Varint).bool(message.enabled)
    /* evmos.erc20.v1.Owner contract_owner = 4; */
    if (message.contractOwner !== 0)
      writer.tag(4, WireType.Varint).int32(message.contractOwner)
    let u = options.writeUnknownFields
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      )
    return writer
  }
}
/**
 * @generated MessageType for protobuf messages evmos.erc20.v1.TokenPair
 */
export const TokenPair = new TokenPair$Type()
// @generated messages type with reflection information, may provide speed optimized methods
class RegisterCoinProposal$Type extends MessageType<RegisterCoinProposal> {
  constructor() {
    super(
      'evmos.erc20.v1.RegisterCoinProposal',
      [
        { no: 1, name: 'title', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
        {
          no: 2,
          name: 'description',
          kind: 'scalar',
          T: 9 /*ScalarType.STRING*/,
        },
        {
          no: 3,
          name: 'metadata',
          kind: 'message',
          T: () => Metadata,
          options: { 'gogoproto.nullable': false },
        },
      ],
      { 'gogoproto.equal': false },
    )
  }
  create(value?: PartialMessage<RegisterCoinProposal>): RegisterCoinProposal {
    const message = { title: '', description: '' }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    })
    if (value !== undefined)
      reflectionMergePartial<RegisterCoinProposal>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: RegisterCoinProposal,
  ): RegisterCoinProposal {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string title */ 1:
          message.title = reader.string()
          break
        case /* string description */ 2:
          message.description = reader.string()
          break
        case /* cosmos.bank.v1beta1.Metadata metadata */ 3:
          message.metadata = Metadata.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.metadata,
          )
          break
        default:
          let u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: RegisterCoinProposal,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string title = 1; */
    if (message.title !== '')
      writer.tag(1, WireType.LengthDelimited).string(message.title)
    /* string description = 2; */
    if (message.description !== '')
      writer.tag(2, WireType.LengthDelimited).string(message.description)
    /* cosmos.bank.v1beta1.Metadata metadata = 3; */
    if (message.metadata)
      Metadata.internalBinaryWrite(
        message.metadata,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options,
      ).join()
    let u = options.writeUnknownFields
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      )
    return writer
  }
}
/**
 * @generated MessageType for protobuf messages evmos.erc20.v1.RegisterCoinProposal
 */
export const RegisterCoinProposal = new RegisterCoinProposal$Type()
// @generated messages type with reflection information, may provide speed optimized methods
class RegisterERC20Proposal$Type extends MessageType<RegisterERC20Proposal> {
  constructor() {
    super(
      'evmos.erc20.v1.RegisterERC20Proposal',
      [
        { no: 1, name: 'title', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
        {
          no: 2,
          name: 'description',
          kind: 'scalar',
          T: 9 /*ScalarType.STRING*/,
        },
        {
          no: 3,
          name: 'erc20address',
          kind: 'scalar',
          jsonName: 'erc20address',
          T: 9 /*ScalarType.STRING*/,
        },
      ],
      { 'gogoproto.equal': false },
    )
  }
  create(value?: PartialMessage<RegisterERC20Proposal>): RegisterERC20Proposal {
    const message = { title: '', description: '', erc20Address: '' }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    })
    if (value !== undefined)
      reflectionMergePartial<RegisterERC20Proposal>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: RegisterERC20Proposal,
  ): RegisterERC20Proposal {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string title */ 1:
          message.title = reader.string()
          break
        case /* string description */ 2:
          message.description = reader.string()
          break
        case /* string erc20address = 3 [json_name = "erc20address"];*/ 3:
          message.erc20Address = reader.string()
          break
        default:
          let u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: RegisterERC20Proposal,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string title = 1; */
    if (message.title !== '')
      writer.tag(1, WireType.LengthDelimited).string(message.title)
    /* string description = 2; */
    if (message.description !== '')
      writer.tag(2, WireType.LengthDelimited).string(message.description)
    /* string erc20address = 3 [json_name = "erc20address"]; */
    if (message.erc20Address !== '')
      writer.tag(3, WireType.LengthDelimited).string(message.erc20Address)
    let u = options.writeUnknownFields
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      )
    return writer
  }
}
/**
 * @generated MessageType for protobuf messages evmos.erc20.v1.RegisterERC20Proposal
 */
export const RegisterERC20Proposal = new RegisterERC20Proposal$Type()
// @generated messages type with reflection information, may provide speed optimized methods
class ToggleTokenRelayProposal$Type extends MessageType<ToggleTokenRelayProposal> {
  constructor() {
    super(
      'evmos.erc20.v1.ToggleTokenRelayProposal',
      [
        { no: 1, name: 'title', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
        {
          no: 2,
          name: 'description',
          kind: 'scalar',
          T: 9 /*ScalarType.STRING*/,
        },
        { no: 3, name: 'token', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      ],
      { 'gogoproto.equal': true },
    )
  }
  create(
    value?: PartialMessage<ToggleTokenRelayProposal>,
  ): ToggleTokenRelayProposal {
    const message = { title: '', description: '', token: '' }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    })
    if (value !== undefined)
      reflectionMergePartial<ToggleTokenRelayProposal>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ToggleTokenRelayProposal,
  ): ToggleTokenRelayProposal {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string title */ 1:
          message.title = reader.string()
          break
        case /* string description */ 2:
          message.description = reader.string()
          break
        case /* string token */ 3:
          message.token = reader.string()
          break
        default:
          let u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: ToggleTokenRelayProposal,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string title = 1; */
    if (message.title !== '')
      writer.tag(1, WireType.LengthDelimited).string(message.title)
    /* string description = 2; */
    if (message.description !== '')
      writer.tag(2, WireType.LengthDelimited).string(message.description)
    /* string token = 3; */
    if (message.token !== '')
      writer.tag(3, WireType.LengthDelimited).string(message.token)
    let u = options.writeUnknownFields
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      )
    return writer
  }
}
/**
 * @generated MessageType for protobuf messages evmos.erc20.v1.ToggleTokenRelayProposal
 */
export const ToggleTokenRelayProposal = new ToggleTokenRelayProposal$Type()
// @generated messages type with reflection information, may provide speed optimized methods
class UpdateTokenPairERC20Proposal$Type extends MessageType<UpdateTokenPairERC20Proposal> {
  constructor() {
    super(
      'evmos.erc20.v1.UpdateTokenPairERC20Proposal',
      [
        { no: 1, name: 'title', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
        {
          no: 2,
          name: 'description',
          kind: 'scalar',
          T: 9 /*ScalarType.STRING*/,
        },
        {
          no: 3,
          name: 'erc20_address',
          kind: 'scalar',
          T: 9 /*ScalarType.STRING*/,
        },
        {
          no: 4,
          name: 'new_erc20_address',
          kind: 'scalar',
          T: 9 /*ScalarType.STRING*/,
        },
      ],
      { 'gogoproto.equal': true },
    )
  }
  create(
    value?: PartialMessage<UpdateTokenPairERC20Proposal>,
  ): UpdateTokenPairERC20Proposal {
    const message = {
      title: '',
      description: '',
      erc20Address: '',
      newErc20Address: '',
    }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    })
    if (value !== undefined)
      reflectionMergePartial<UpdateTokenPairERC20Proposal>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: UpdateTokenPairERC20Proposal,
  ): UpdateTokenPairERC20Proposal {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string title */ 1:
          message.title = reader.string()
          break
        case /* string description */ 2:
          message.description = reader.string()
          break
        case /* string erc20_address */ 3:
          message.erc20Address = reader.string()
          break
        case /* string new_erc20_address */ 4:
          message.newErc20Address = reader.string()
          break
        default:
          let u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: UpdateTokenPairERC20Proposal,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string title = 1; */
    if (message.title !== '')
      writer.tag(1, WireType.LengthDelimited).string(message.title)
    /* string description = 2; */
    if (message.description !== '')
      writer.tag(2, WireType.LengthDelimited).string(message.description)
    /* string erc20_address = 3; */
    if (message.erc20Address !== '')
      writer.tag(3, WireType.LengthDelimited).string(message.erc20Address)
    /* string new_erc20_address = 4; */
    if (message.newErc20Address !== '')
      writer.tag(4, WireType.LengthDelimited).string(message.newErc20Address)
    let u = options.writeUnknownFields
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      )
    return writer
  }
}
/**
 * @generated MessageType for protobuf messages evmos.erc20.v1.UpdateTokenPairERC20Proposal
 */
export const UpdateTokenPairERC20Proposal =
  new UpdateTokenPairERC20Proposal$Type()
