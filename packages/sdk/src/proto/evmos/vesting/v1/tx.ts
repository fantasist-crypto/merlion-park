// @ts-nocheck
// @generated by protobuf-ts 2.5.0 with parameter long_type_string
// @generated from protobuf file "evmos/vesting/v1/tx.proto" (package "evmos.vesting.v1", syntax proto3)
// tslint:disable
import { ServiceType } from '@protobuf-ts/runtime-rpc'
import type { BinaryWriteOptions } from '@protobuf-ts/runtime'
import type { IBinaryWriter } from '@protobuf-ts/runtime'
import { WireType } from '@protobuf-ts/runtime'
import type { BinaryReadOptions } from '@protobuf-ts/runtime'
import type { IBinaryReader } from '@protobuf-ts/runtime'
import { UnknownFieldHandler } from '@protobuf-ts/runtime'
import type { PartialMessage } from '@protobuf-ts/runtime'
import { reflectionMergePartial } from '@protobuf-ts/runtime'
import { MESSAGE_TYPE } from '@protobuf-ts/runtime'
import { MessageType } from '@protobuf-ts/runtime'
import { Period } from '../../../cosmos/vesting/v1beta1/vesting'
import { Timestamp } from '../../../google/protobuf/timestamp'
/**
 * MsgCreateClawbackVestingAccount defines a messages that enables creating a ClawbackVestingAccount.
 *
 * @generated from protobuf messages evmos.vesting.v1.MsgCreateClawbackVestingAccount
 */
export interface MsgCreateClawbackVestingAccount {
  /**
   * from_address specifies the account to provide the funds and sign the
   * clawback request
   *
   * @generated from protobuf field: string from_address = 1;
   */
  fromAddress: string
  /**
   * to_address specifies the account to receive the funds
   *
   * @generated from protobuf field: string to_address = 2;
   */
  toAddress: string
  /**
   * start_time defines the time at which the vesting period begins
   *
   * @generated from protobuf field: google.protobuf.Timestamp start_time = 3;
   */
  startTime?: Timestamp
  /**
   * lockup_periods defines the unlocking schedule relative to the start_time
   *
   * @generated from protobuf field: repeated cosmos.vesting.v1beta1.Period lockup_periods = 4;
   */
  lockupPeriods: Period[]
  /**
   * vesting_periods defines thevesting schedule relative to the start_time
   *
   * @generated from protobuf field: repeated cosmos.vesting.v1beta1.Period vesting_periods = 5;
   */
  vestingPeriods: Period[]
  /**
   * merge specifies a the creation mechanism for existing
   * ClawbackVestingAccounts. If true, merge this new grant into an existing
   * ClawbackVestingAccount, or create it if it does not exist. If false,
   * creates a new account. New grants to an existing account must be from the
   * same from_address.
   *
   * @generated from protobuf field: bool merge = 6;
   */
  merge: boolean
}
/**
 * MsgCreateClawbackVestingAccountResponse defines the
 * MsgCreateClawbackVestingAccount response type.
 *
 * @generated from protobuf messages evmos.vesting.v1.MsgCreateClawbackVestingAccountResponse
 */
export interface MsgCreateClawbackVestingAccountResponse {}
/**
 * MsgClawback defines a messages that removes unvested tokens from a
 * ClawbackVestingAccount.
 *
 * @generated from protobuf messages evmos.vesting.v1.MsgClawback
 */
export interface MsgClawback {
  /**
   * funder_address is the address which funded the account
   *
   * @generated from protobuf field: string funder_address = 1;
   */
  funderAddress: string
  /**
   * account_address is the address of the ClawbackVestingAccount to claw back from.
   *
   * @generated from protobuf field: string account_address = 2;
   */
  accountAddress: string
  /**
   * dest_address specifies where the clawed-back tokens should be transferred
   * to. If empty, the tokens will be transferred back to the original funder of
   * the account.
   *
   * @generated from protobuf field: string dest_address = 3;
   */
  destAddress: string
}
/**
 * MsgClawbackResponse defines the MsgClawback response type.
 *
 * @generated from protobuf messages evmos.vesting.v1.MsgClawbackResponse
 */
export interface MsgClawbackResponse {}
// @generated messages type with reflection information, may provide speed optimized methods
class MsgCreateClawbackVestingAccount$Type extends MessageType<MsgCreateClawbackVestingAccount> {
  constructor() {
    super(
      'evmos.vesting.v1.MsgCreateClawbackVestingAccount',
      [
        {
          no: 1,
          name: 'from_address',
          kind: 'scalar',
          T: 9 /*ScalarType.STRING*/,
        },
        {
          no: 2,
          name: 'to_address',
          kind: 'scalar',
          T: 9 /*ScalarType.STRING*/,
        },
        {
          no: 3,
          name: 'start_time',
          kind: 'message',
          T: () => Timestamp,
          options: { 'gogoproto.nullable': false, 'gogoproto.stdtime': true },
        },
        {
          no: 4,
          name: 'lockup_periods',
          kind: 'message',
          repeat: 1 /*RepeatType.PACKED*/,
          T: () => Period,
          options: { 'gogoproto.nullable': false },
        },
        {
          no: 5,
          name: 'vesting_periods',
          kind: 'message',
          repeat: 1 /*RepeatType.PACKED*/,
          T: () => Period,
          options: { 'gogoproto.nullable': false },
        },
        { no: 6, name: 'merge', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
      ],
      { 'gogoproto.equal': false },
    )
  }
  create(
    value?: PartialMessage<MsgCreateClawbackVestingAccount>,
  ): MsgCreateClawbackVestingAccount {
    const message = {
      fromAddress: '',
      toAddress: '',
      lockupPeriods: [],
      vestingPeriods: [],
      merge: false,
    }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    })
    if (value !== undefined)
      reflectionMergePartial<MsgCreateClawbackVestingAccount>(
        this,
        message,
        value,
      )
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: MsgCreateClawbackVestingAccount,
  ): MsgCreateClawbackVestingAccount {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string from_address */ 1:
          message.fromAddress = reader.string()
          break
        case /* string to_address */ 2:
          message.toAddress = reader.string()
          break
        case /* google.protobuf.Timestamp start_time */ 3:
          message.startTime = Timestamp.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.startTime,
          )
          break
        case /* repeated cosmos.vesting.v1beta1.Period lockup_periods */ 4:
          message.lockupPeriods.push(
            Period.internalBinaryRead(reader, reader.uint32(), options),
          )
          break
        case /* repeated cosmos.vesting.v1beta1.Period vesting_periods */ 5:
          message.vestingPeriods.push(
            Period.internalBinaryRead(reader, reader.uint32(), options),
          )
          break
        case /* bool merge */ 6:
          message.merge = reader.bool()
          break
        default:
          let u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: MsgCreateClawbackVestingAccount,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string from_address = 1; */
    if (message.fromAddress !== '')
      writer.tag(1, WireType.LengthDelimited).string(message.fromAddress)
    /* string to_address = 2; */
    if (message.toAddress !== '')
      writer.tag(2, WireType.LengthDelimited).string(message.toAddress)
    /* google.protobuf.Timestamp start_time = 3; */
    if (message.startTime)
      Timestamp.internalBinaryWrite(
        message.startTime,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options,
      ).join()
    /* repeated cosmos.vesting.v1beta1.Period lockup_periods = 4; */
    for (let i = 0; i < message.lockupPeriods.length; i++)
      Period.internalBinaryWrite(
        message.lockupPeriods[i],
        writer.tag(4, WireType.LengthDelimited).fork(),
        options,
      ).join()
    /* repeated cosmos.vesting.v1beta1.Period vesting_periods = 5; */
    for (let i = 0; i < message.vestingPeriods.length; i++)
      Period.internalBinaryWrite(
        message.vestingPeriods[i],
        writer.tag(5, WireType.LengthDelimited).fork(),
        options,
      ).join()
    /* bool merge = 6; */
    if (message.merge !== false)
      writer.tag(6, WireType.Varint).bool(message.merge)
    let u = options.writeUnknownFields
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      )
    return writer
  }
}
/**
 * @generated MessageType for protobuf messages evmos.vesting.v1.MsgCreateClawbackVestingAccount
 */
export const MsgCreateClawbackVestingAccount =
  new MsgCreateClawbackVestingAccount$Type()
// @generated messages type with reflection information, may provide speed optimized methods
class MsgCreateClawbackVestingAccountResponse$Type extends MessageType<MsgCreateClawbackVestingAccountResponse> {
  constructor() {
    super('evmos.vesting.v1.MsgCreateClawbackVestingAccountResponse', [])
  }
  create(
    value?: PartialMessage<MsgCreateClawbackVestingAccountResponse>,
  ): MsgCreateClawbackVestingAccountResponse {
    const message = {}
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    })
    if (value !== undefined)
      reflectionMergePartial<MsgCreateClawbackVestingAccountResponse>(
        this,
        message,
        value,
      )
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: MsgCreateClawbackVestingAccountResponse,
  ): MsgCreateClawbackVestingAccountResponse {
    return target ?? this.create()
  }
  internalBinaryWrite(
    message: MsgCreateClawbackVestingAccountResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    let u = options.writeUnknownFields
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      )
    return writer
  }
}
/**
 * @generated MessageType for protobuf messages evmos.vesting.v1.MsgCreateClawbackVestingAccountResponse
 */
export const MsgCreateClawbackVestingAccountResponse =
  new MsgCreateClawbackVestingAccountResponse$Type()
// @generated messages type with reflection information, may provide speed optimized methods
class MsgClawback$Type extends MessageType<MsgClawback> {
  constructor() {
    super('evmos.vesting.v1.MsgClawback', [
      {
        no: 1,
        name: 'funder_address',
        kind: 'scalar',
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 2,
        name: 'account_address',
        kind: 'scalar',
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 3,
        name: 'dest_address',
        kind: 'scalar',
        T: 9 /*ScalarType.STRING*/,
      },
    ])
  }
  create(value?: PartialMessage<MsgClawback>): MsgClawback {
    const message = { funderAddress: '', accountAddress: '', destAddress: '' }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    })
    if (value !== undefined)
      reflectionMergePartial<MsgClawback>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: MsgClawback,
  ): MsgClawback {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string funder_address */ 1:
          message.funderAddress = reader.string()
          break
        case /* string account_address */ 2:
          message.accountAddress = reader.string()
          break
        case /* string dest_address */ 3:
          message.destAddress = reader.string()
          break
        default:
          let u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: MsgClawback,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string funder_address = 1; */
    if (message.funderAddress !== '')
      writer.tag(1, WireType.LengthDelimited).string(message.funderAddress)
    /* string account_address = 2; */
    if (message.accountAddress !== '')
      writer.tag(2, WireType.LengthDelimited).string(message.accountAddress)
    /* string dest_address = 3; */
    if (message.destAddress !== '')
      writer.tag(3, WireType.LengthDelimited).string(message.destAddress)
    let u = options.writeUnknownFields
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      )
    return writer
  }
}
/**
 * @generated MessageType for protobuf messages evmos.vesting.v1.MsgClawback
 */
export const MsgClawback = new MsgClawback$Type()
// @generated messages type with reflection information, may provide speed optimized methods
class MsgClawbackResponse$Type extends MessageType<MsgClawbackResponse> {
  constructor() {
    super('evmos.vesting.v1.MsgClawbackResponse', [])
  }
  create(value?: PartialMessage<MsgClawbackResponse>): MsgClawbackResponse {
    const message = {}
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    })
    if (value !== undefined)
      reflectionMergePartial<MsgClawbackResponse>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: MsgClawbackResponse,
  ): MsgClawbackResponse {
    return target ?? this.create()
  }
  internalBinaryWrite(
    message: MsgClawbackResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    let u = options.writeUnknownFields
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      )
    return writer
  }
}
/**
 * @generated MessageType for protobuf messages evmos.vesting.v1.MsgClawbackResponse
 */
export const MsgClawbackResponse = new MsgClawbackResponse$Type()
/**
 * @generated ServiceType for protobuf service evmos.vesting.v1.Msg
 */
export const Msg = new ServiceType('evmos.vesting.v1.Msg', [
  {
    name: 'CreateClawbackVestingAccount',
    options: {
      'google.api.http': {
        get: '/evmos/vesting/v1/tx/create_clawback_vesting_account',
      },
    },
    I: MsgCreateClawbackVestingAccount,
    O: MsgCreateClawbackVestingAccountResponse,
  },
  {
    name: 'Clawback',
    options: { 'google.api.http': { get: '/evmos/vesting/v1/tx/clawback' } },
    I: MsgClawback,
    O: MsgClawbackResponse,
  },
])
