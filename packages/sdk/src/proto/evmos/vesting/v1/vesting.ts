// @ts-nocheck
// @generated by protobuf-ts 2.5.0 with parameter long_type_string
// @generated from protobuf file "evmos/vesting/v1/vesting.proto" (package "evmos.vesting.v1", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from '@protobuf-ts/runtime'
import type { IBinaryWriter } from '@protobuf-ts/runtime'
import { WireType } from '@protobuf-ts/runtime'
import type { BinaryReadOptions } from '@protobuf-ts/runtime'
import type { IBinaryReader } from '@protobuf-ts/runtime'
import { UnknownFieldHandler } from '@protobuf-ts/runtime'
import type { PartialMessage } from '@protobuf-ts/runtime'
import { reflectionMergePartial } from '@protobuf-ts/runtime'
import { MESSAGE_TYPE } from '@protobuf-ts/runtime'
import { MessageType } from '@protobuf-ts/runtime'
import { Period } from '../../../cosmos/vesting/v1beta1/vesting'
import { Timestamp } from '../../../google/protobuf/timestamp'
import { BaseVestingAccount } from '../../../cosmos/vesting/v1beta1/vesting'
/**
 * ClawbackVestingAccount implements the VestingAccount interface. It provides
 * an account that can hold contributions subject to "lockup" (like a
 * PeriodicVestingAccount), or vesting which is subject to clawback
 * of unvested tokens, or a combination (tokens vest, but are still locked).
 *
 * @generated from protobuf messages evmos.vesting.v1.ClawbackVestingAccount
 */
export interface ClawbackVestingAccount {
  /**
   * base_vesting_account implements the VestingAccount interface. It contains
   * all the necessary fields needed for any vesting account implementation
   *
   * @generated from protobuf field: cosmos.vesting.v1beta1.BaseVestingAccount base_vesting_account = 1;
   */
  baseVestingAccount?: BaseVestingAccount
  /**
   * funder_address specifies the account which can perform clawback
   *
   * @generated from protobuf field: string funder_address = 2;
   */
  funderAddress: string
  /**
   * start_time defines the time at which the vesting period begins
   *
   * @generated from protobuf field: google.protobuf.Timestamp start_time = 3;
   */
  startTime?: Timestamp
  /**
   * lockup_periods defines the unlocking schedule relative to the start_time
   *
   * @generated from protobuf field: repeated cosmos.vesting.v1beta1.Period lockup_periods = 4;
   */
  lockupPeriods: Period[]
  /**
   * vesting_periods defines the vesting schedule relative to the start_time
   *
   * @generated from protobuf field: repeated cosmos.vesting.v1beta1.Period vesting_periods = 5;
   */
  vestingPeriods: Period[]
}
// @generated messages type with reflection information, may provide speed optimized methods
class ClawbackVestingAccount$Type extends MessageType<ClawbackVestingAccount> {
  constructor() {
    super(
      'evmos.vesting.v1.ClawbackVestingAccount',
      [
        {
          no: 1,
          name: 'base_vesting_account',
          kind: 'message',
          T: () => BaseVestingAccount,
          options: { 'gogoproto.embed': true },
        },
        {
          no: 2,
          name: 'funder_address',
          kind: 'scalar',
          T: 9 /*ScalarType.STRING*/,
        },
        {
          no: 3,
          name: 'start_time',
          kind: 'message',
          T: () => Timestamp,
          options: { 'gogoproto.nullable': false, 'gogoproto.stdtime': true },
        },
        {
          no: 4,
          name: 'lockup_periods',
          kind: 'message',
          repeat: 1 /*RepeatType.PACKED*/,
          T: () => Period,
          options: { 'gogoproto.nullable': false },
        },
        {
          no: 5,
          name: 'vesting_periods',
          kind: 'message',
          repeat: 1 /*RepeatType.PACKED*/,
          T: () => Period,
          options: { 'gogoproto.nullable': false },
        },
      ],
      {
        'gogoproto.goproto_getters': false,
        'gogoproto.goproto_stringer': false,
      },
    )
  }
  create(
    value?: PartialMessage<ClawbackVestingAccount>,
  ): ClawbackVestingAccount {
    const message = { funderAddress: '', lockupPeriods: [], vestingPeriods: [] }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    })
    if (value !== undefined)
      reflectionMergePartial<ClawbackVestingAccount>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ClawbackVestingAccount,
  ): ClawbackVestingAccount {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* cosmos.vesting.v1beta1.BaseVestingAccount base_vesting_account */ 1:
          message.baseVestingAccount = BaseVestingAccount.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.baseVestingAccount,
          )
          break
        case /* string funder_address */ 2:
          message.funderAddress = reader.string()
          break
        case /* google.protobuf.Timestamp start_time */ 3:
          message.startTime = Timestamp.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.startTime,
          )
          break
        case /* repeated cosmos.vesting.v1beta1.Period lockup_periods */ 4:
          message.lockupPeriods.push(
            Period.internalBinaryRead(reader, reader.uint32(), options),
          )
          break
        case /* repeated cosmos.vesting.v1beta1.Period vesting_periods */ 5:
          message.vestingPeriods.push(
            Period.internalBinaryRead(reader, reader.uint32(), options),
          )
          break
        default:
          let u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: ClawbackVestingAccount,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* cosmos.vesting.v1beta1.BaseVestingAccount base_vesting_account = 1; */
    if (message.baseVestingAccount)
      BaseVestingAccount.internalBinaryWrite(
        message.baseVestingAccount,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join()
    /* string funder_address = 2; */
    if (message.funderAddress !== '')
      writer.tag(2, WireType.LengthDelimited).string(message.funderAddress)
    /* google.protobuf.Timestamp start_time = 3; */
    if (message.startTime)
      Timestamp.internalBinaryWrite(
        message.startTime,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options,
      ).join()
    /* repeated cosmos.vesting.v1beta1.Period lockup_periods = 4; */
    for (let i = 0; i < message.lockupPeriods.length; i++)
      Period.internalBinaryWrite(
        message.lockupPeriods[i],
        writer.tag(4, WireType.LengthDelimited).fork(),
        options,
      ).join()
    /* repeated cosmos.vesting.v1beta1.Period vesting_periods = 5; */
    for (let i = 0; i < message.vestingPeriods.length; i++)
      Period.internalBinaryWrite(
        message.vestingPeriods[i],
        writer.tag(5, WireType.LengthDelimited).fork(),
        options,
      ).join()
    let u = options.writeUnknownFields
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      )
    return writer
  }
}
/**
 * @generated MessageType for protobuf messages evmos.vesting.v1.ClawbackVestingAccount
 */
export const ClawbackVestingAccount = new ClawbackVestingAccount$Type()
