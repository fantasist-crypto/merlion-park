// @ts-nocheck
// @generated by protobuf-ts 2.5.0 with parameter long_type_string
// @generated from protobuf file "evmos/claims/v1/query.proto" (package "evmos.claims.v1", syntax proto3)
// tslint:disable
import { ServiceType } from '@protobuf-ts/runtime-rpc'
import { WireType } from '@protobuf-ts/runtime'
import type { BinaryWriteOptions } from '@protobuf-ts/runtime'
import type { IBinaryWriter } from '@protobuf-ts/runtime'
import { UnknownFieldHandler } from '@protobuf-ts/runtime'
import type { BinaryReadOptions } from '@protobuf-ts/runtime'
import type { IBinaryReader } from '@protobuf-ts/runtime'
import type { PartialMessage } from '@protobuf-ts/runtime'
import { reflectionMergePartial } from '@protobuf-ts/runtime'
import { MESSAGE_TYPE } from '@protobuf-ts/runtime'
import { MessageType } from '@protobuf-ts/runtime'
import { Claim } from './claims'
import { PageResponse } from '../../../cosmos/base/query/v1beta1/pagination'
import { ClaimsRecordAddress } from './claims'
import { PageRequest } from '../../../cosmos/base/query/v1beta1/pagination'
import { Params } from './genesis'
import { Coin } from '../../../cosmos/base/v1beta1/coin'
/**
 * QueryTotalUnclaimedRequest is the request type for the Query/TotalUnclaimed
 * RPC method.
 *
 * @generated from protobuf messages evmos.claims.v1.QueryTotalUnclaimedRequest
 */
export interface QueryTotalUnclaimedRequest {}
/**
 * QueryTotalUnclaimedResponse is the response type for the Query/TotalUnclaimed
 * RPC method.
 *
 * @generated from protobuf messages evmos.claims.v1.QueryTotalUnclaimedResponse
 */
export interface QueryTotalUnclaimedResponse {
  /**
   * coins defines the unclaimed coins
   *
   * @generated from protobuf field: repeated cosmos.base.v1beta1.Coin coins = 1;
   */
  coins: Coin[]
}
/**
 * QueryParamsRequest is the request type for the Query/Params RPC method.
 *
 * @generated from protobuf messages evmos.claims.v1.QueryParamsRequest
 */
export interface QueryParamsRequest {}
/**
 * QueryParamsResponse is the response type for the Query/Params RPC method.
 *
 * @generated from protobuf messages evmos.claims.v1.QueryParamsResponse
 */
export interface QueryParamsResponse {
  /**
   * params defines the parameters of the module.
   *
   * @generated from protobuf field: evmos.claims.v1.Params params = 1;
   */
  params?: Params
}
/**
 * QueryClaimsRecordsRequest is the request type for the Query/ClaimsRecords RPC
 * method.
 *
 * @generated from protobuf messages evmos.claims.v1.QueryClaimsRecordsRequest
 */
export interface QueryClaimsRecordsRequest {
  /**
   * pagination defines an optional pagination for the request.
   *
   * @generated from protobuf field: cosmos.base.query.v1beta1.PageRequest pagination = 1;
   */
  pagination?: PageRequest
}
/**
 * QueryClaimsRecordsResponse is the response type for the Query/ClaimsRecords
 * RPC method.
 *
 * @generated from protobuf messages evmos.claims.v1.QueryClaimsRecordsResponse
 */
export interface QueryClaimsRecordsResponse {
  /**
   * claims defines all claims records
   *
   * @generated from protobuf field: repeated evmos.claims.v1.ClaimsRecordAddress claims = 1;
   */
  claims: ClaimsRecordAddress[]
  /**
   * pagination defines the pagination in the response.
   *
   * @generated from protobuf field: cosmos.base.query.v1beta1.PageResponse pagination = 2;
   */
  pagination?: PageResponse
}
/**
 * QueryClaimsRecordRequest is the request type for the Query/ClaimsRecord RPC
 * method.
 *
 * @generated from protobuf messages evmos.claims.v1.QueryClaimsRecordRequest
 */
export interface QueryClaimsRecordRequest {
  /**
   * address defines the user to query claims record for
   *
   * @generated from protobuf field: string address = 1;
   */
  address: string
}
/**
 * QueryClaimsRecordResponse is the response type for the Query/ClaimsRecord RPC
 * method.
 *
 * @generated from protobuf messages evmos.claims.v1.QueryClaimsRecordResponse
 */
export interface QueryClaimsRecordResponse {
  /**
   * total initial claimable amount for the user
   *
   * @generated from protobuf field: string initial_claimable_amount = 1;
   */
  initialClaimableAmount: string
  /**
   * the claims of the user
   *
   * @generated from protobuf field: repeated evmos.claims.v1.Claim claims = 2;
   */
  claims: Claim[]
}
// @generated messages type with reflection information, may provide speed optimized methods
class QueryTotalUnclaimedRequest$Type extends MessageType<QueryTotalUnclaimedRequest> {
  constructor() {
    super('evmos.claims.v1.QueryTotalUnclaimedRequest', [])
  }
  create(
    value?: PartialMessage<QueryTotalUnclaimedRequest>,
  ): QueryTotalUnclaimedRequest {
    const message = {}
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    })
    if (value !== undefined)
      reflectionMergePartial<QueryTotalUnclaimedRequest>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: QueryTotalUnclaimedRequest,
  ): QueryTotalUnclaimedRequest {
    return target ?? this.create()
  }
  internalBinaryWrite(
    message: QueryTotalUnclaimedRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    let u = options.writeUnknownFields
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      )
    return writer
  }
}
/**
 * @generated MessageType for protobuf messages evmos.claims.v1.QueryTotalUnclaimedRequest
 */
export const QueryTotalUnclaimedRequest = new QueryTotalUnclaimedRequest$Type()
// @generated messages type with reflection information, may provide speed optimized methods
class QueryTotalUnclaimedResponse$Type extends MessageType<QueryTotalUnclaimedResponse> {
  constructor() {
    super('evmos.claims.v1.QueryTotalUnclaimedResponse', [
      {
        no: 1,
        name: 'coins',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => Coin,
        options: {
          'gogoproto.nullable': false,
          'gogoproto.castrepeated': 'github.com/cosmos/cosmos-sdk/types.Coins',
        },
      },
    ])
  }
  create(
    value?: PartialMessage<QueryTotalUnclaimedResponse>,
  ): QueryTotalUnclaimedResponse {
    const message = { coins: [] }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    })
    if (value !== undefined)
      reflectionMergePartial<QueryTotalUnclaimedResponse>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: QueryTotalUnclaimedResponse,
  ): QueryTotalUnclaimedResponse {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* repeated cosmos.base.v1beta1.Coin coins */ 1:
          message.coins.push(
            Coin.internalBinaryRead(reader, reader.uint32(), options),
          )
          break
        default:
          let u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: QueryTotalUnclaimedResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated cosmos.base.v1beta1.Coin coins = 1; */
    for (let i = 0; i < message.coins.length; i++)
      Coin.internalBinaryWrite(
        message.coins[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join()
    let u = options.writeUnknownFields
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      )
    return writer
  }
}
/**
 * @generated MessageType for protobuf messages evmos.claims.v1.QueryTotalUnclaimedResponse
 */
export const QueryTotalUnclaimedResponse =
  new QueryTotalUnclaimedResponse$Type()
// @generated messages type with reflection information, may provide speed optimized methods
class QueryParamsRequest$Type extends MessageType<QueryParamsRequest> {
  constructor() {
    super('evmos.claims.v1.QueryParamsRequest', [])
  }
  create(value?: PartialMessage<QueryParamsRequest>): QueryParamsRequest {
    const message = {}
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    })
    if (value !== undefined)
      reflectionMergePartial<QueryParamsRequest>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: QueryParamsRequest,
  ): QueryParamsRequest {
    return target ?? this.create()
  }
  internalBinaryWrite(
    message: QueryParamsRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    let u = options.writeUnknownFields
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      )
    return writer
  }
}
/**
 * @generated MessageType for protobuf messages evmos.claims.v1.QueryParamsRequest
 */
export const QueryParamsRequest = new QueryParamsRequest$Type()
// @generated messages type with reflection information, may provide speed optimized methods
class QueryParamsResponse$Type extends MessageType<QueryParamsResponse> {
  constructor() {
    super('evmos.claims.v1.QueryParamsResponse', [
      {
        no: 1,
        name: 'params',
        kind: 'message',
        T: () => Params,
        options: { 'gogoproto.nullable': false },
      },
    ])
  }
  create(value?: PartialMessage<QueryParamsResponse>): QueryParamsResponse {
    const message = {}
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    })
    if (value !== undefined)
      reflectionMergePartial<QueryParamsResponse>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: QueryParamsResponse,
  ): QueryParamsResponse {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* evmos.claims.v1.Params params */ 1:
          message.params = Params.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.params,
          )
          break
        default:
          let u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: QueryParamsResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* evmos.claims.v1.Params params = 1; */
    if (message.params)
      Params.internalBinaryWrite(
        message.params,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join()
    let u = options.writeUnknownFields
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      )
    return writer
  }
}
/**
 * @generated MessageType for protobuf messages evmos.claims.v1.QueryParamsResponse
 */
export const QueryParamsResponse = new QueryParamsResponse$Type()
// @generated messages type with reflection information, may provide speed optimized methods
class QueryClaimsRecordsRequest$Type extends MessageType<QueryClaimsRecordsRequest> {
  constructor() {
    super('evmos.claims.v1.QueryClaimsRecordsRequest', [
      { no: 1, name: 'pagination', kind: 'message', T: () => PageRequest },
    ])
  }
  create(
    value?: PartialMessage<QueryClaimsRecordsRequest>,
  ): QueryClaimsRecordsRequest {
    const message = {}
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    })
    if (value !== undefined)
      reflectionMergePartial<QueryClaimsRecordsRequest>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: QueryClaimsRecordsRequest,
  ): QueryClaimsRecordsRequest {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* cosmos.base.query.v1beta1.PageRequest pagination */ 1:
          message.pagination = PageRequest.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.pagination,
          )
          break
        default:
          let u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: QueryClaimsRecordsRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* cosmos.base.query.v1beta1.PageRequest pagination = 1; */
    if (message.pagination)
      PageRequest.internalBinaryWrite(
        message.pagination,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join()
    let u = options.writeUnknownFields
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      )
    return writer
  }
}
/**
 * @generated MessageType for protobuf messages evmos.claims.v1.QueryClaimsRecordsRequest
 */
export const QueryClaimsRecordsRequest = new QueryClaimsRecordsRequest$Type()
// @generated messages type with reflection information, may provide speed optimized methods
class QueryClaimsRecordsResponse$Type extends MessageType<QueryClaimsRecordsResponse> {
  constructor() {
    super('evmos.claims.v1.QueryClaimsRecordsResponse', [
      {
        no: 1,
        name: 'claims',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => ClaimsRecordAddress,
        options: { 'gogoproto.nullable': false },
      },
      { no: 2, name: 'pagination', kind: 'message', T: () => PageResponse },
    ])
  }
  create(
    value?: PartialMessage<QueryClaimsRecordsResponse>,
  ): QueryClaimsRecordsResponse {
    const message = { claims: [] }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    })
    if (value !== undefined)
      reflectionMergePartial<QueryClaimsRecordsResponse>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: QueryClaimsRecordsResponse,
  ): QueryClaimsRecordsResponse {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* repeated evmos.claims.v1.ClaimsRecordAddress claims */ 1:
          message.claims.push(
            ClaimsRecordAddress.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          )
          break
        case /* cosmos.base.query.v1beta1.PageResponse pagination */ 2:
          message.pagination = PageResponse.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.pagination,
          )
          break
        default:
          let u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: QueryClaimsRecordsResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated evmos.claims.v1.ClaimsRecordAddress claims = 1; */
    for (let i = 0; i < message.claims.length; i++)
      ClaimsRecordAddress.internalBinaryWrite(
        message.claims[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join()
    /* cosmos.base.query.v1beta1.PageResponse pagination = 2; */
    if (message.pagination)
      PageResponse.internalBinaryWrite(
        message.pagination,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join()
    let u = options.writeUnknownFields
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      )
    return writer
  }
}
/**
 * @generated MessageType for protobuf messages evmos.claims.v1.QueryClaimsRecordsResponse
 */
export const QueryClaimsRecordsResponse = new QueryClaimsRecordsResponse$Type()
// @generated messages type with reflection information, may provide speed optimized methods
class QueryClaimsRecordRequest$Type extends MessageType<QueryClaimsRecordRequest> {
  constructor() {
    super('evmos.claims.v1.QueryClaimsRecordRequest', [
      { no: 1, name: 'address', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
    ])
  }
  create(
    value?: PartialMessage<QueryClaimsRecordRequest>,
  ): QueryClaimsRecordRequest {
    const message = { address: '' }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    })
    if (value !== undefined)
      reflectionMergePartial<QueryClaimsRecordRequest>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: QueryClaimsRecordRequest,
  ): QueryClaimsRecordRequest {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string address */ 1:
          message.address = reader.string()
          break
        default:
          let u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: QueryClaimsRecordRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string address = 1; */
    if (message.address !== '')
      writer.tag(1, WireType.LengthDelimited).string(message.address)
    let u = options.writeUnknownFields
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      )
    return writer
  }
}
/**
 * @generated MessageType for protobuf messages evmos.claims.v1.QueryClaimsRecordRequest
 */
export const QueryClaimsRecordRequest = new QueryClaimsRecordRequest$Type()
// @generated messages type with reflection information, may provide speed optimized methods
class QueryClaimsRecordResponse$Type extends MessageType<QueryClaimsRecordResponse> {
  constructor() {
    super('evmos.claims.v1.QueryClaimsRecordResponse', [
      {
        no: 1,
        name: 'initial_claimable_amount',
        kind: 'scalar',
        T: 9 /*ScalarType.STRING*/,
        options: {
          'gogoproto.nullable': false,
          'gogoproto.customtype': 'github.com/cosmos/cosmos-sdk/types.Int',
        },
      },
      {
        no: 2,
        name: 'claims',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => Claim,
        options: { 'gogoproto.nullable': false },
      },
    ])
  }
  create(
    value?: PartialMessage<QueryClaimsRecordResponse>,
  ): QueryClaimsRecordResponse {
    const message = { initialClaimableAmount: '', claims: [] }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    })
    if (value !== undefined)
      reflectionMergePartial<QueryClaimsRecordResponse>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: QueryClaimsRecordResponse,
  ): QueryClaimsRecordResponse {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string initial_claimable_amount */ 1:
          message.initialClaimableAmount = reader.string()
          break
        case /* repeated evmos.claims.v1.Claim claims */ 2:
          message.claims.push(
            Claim.internalBinaryRead(reader, reader.uint32(), options),
          )
          break
        default:
          let u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: QueryClaimsRecordResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string initial_claimable_amount = 1; */
    if (message.initialClaimableAmount !== '')
      writer
        .tag(1, WireType.LengthDelimited)
        .string(message.initialClaimableAmount)
    /* repeated evmos.claims.v1.Claim claims = 2; */
    for (let i = 0; i < message.claims.length; i++)
      Claim.internalBinaryWrite(
        message.claims[i],
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join()
    let u = options.writeUnknownFields
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      )
    return writer
  }
}
/**
 * @generated MessageType for protobuf messages evmos.claims.v1.QueryClaimsRecordResponse
 */
export const QueryClaimsRecordResponse = new QueryClaimsRecordResponse$Type()
/**
 * @generated ServiceType for protobuf service evmos.claims.v1.Query
 */
export const Query = new ServiceType('evmos.claims.v1.Query', [
  {
    name: 'TotalUnclaimed',
    options: { 'google.api.http': { get: '/evmos/claims/v1/total_unclaimed' } },
    I: QueryTotalUnclaimedRequest,
    O: QueryTotalUnclaimedResponse,
  },
  {
    name: 'Params',
    options: { 'google.api.http': { get: '/evmos/claims/v1/params' } },
    I: QueryParamsRequest,
    O: QueryParamsResponse,
  },
  {
    name: 'ClaimsRecords',
    options: { 'google.api.http': { get: '/evmos/claims/v1/claims_records' } },
    I: QueryClaimsRecordsRequest,
    O: QueryClaimsRecordsResponse,
  },
  {
    name: 'ClaimsRecord',
    options: {
      'google.api.http': { get: '/evmos/claims/v1/claims_records/{address}' },
    },
    I: QueryClaimsRecordRequest,
    O: QueryClaimsRecordResponse,
  },
])
