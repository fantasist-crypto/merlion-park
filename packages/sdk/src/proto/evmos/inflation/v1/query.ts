// @ts-nocheck
// @generated by protobuf-ts 2.5.0 with parameter long_type_string
// @generated from protobuf file "evmos/inflation/v1/query.proto" (package "evmos.inflation.v1", syntax proto3)
// tslint:disable
import { ServiceType } from '@protobuf-ts/runtime-rpc'
import { WireType } from '@protobuf-ts/runtime'
import type { BinaryWriteOptions } from '@protobuf-ts/runtime'
import type { IBinaryWriter } from '@protobuf-ts/runtime'
import { UnknownFieldHandler } from '@protobuf-ts/runtime'
import type { BinaryReadOptions } from '@protobuf-ts/runtime'
import type { IBinaryReader } from '@protobuf-ts/runtime'
import type { PartialMessage } from '@protobuf-ts/runtime'
import { reflectionMergePartial } from '@protobuf-ts/runtime'
import { MESSAGE_TYPE } from '@protobuf-ts/runtime'
import { MessageType } from '@protobuf-ts/runtime'
import { Params } from './genesis'
import { DecCoin } from '../../../cosmos/base/v1beta1/coin'
/**
 * QueryPeriodRequest is the request type for the Query/Period RPC method.
 *
 * @generated from protobuf messages evmos.inflation.v1.QueryPeriodRequest
 */
export interface QueryPeriodRequest {}
/**
 * QueryPeriodResponse is the response type for the Query/Period RPC method.
 *
 * @generated from protobuf messages evmos.inflation.v1.QueryPeriodResponse
 */
export interface QueryPeriodResponse {
  /**
   * period is the current minting per epoch provision value.
   *
   * @generated from protobuf field: uint64 period = 1;
   */
  period: string
}
/**
 * QueryEpochMintProvisionRequest is the request type for the
 * Query/EpochMintProvision RPC method.
 *
 * @generated from protobuf messages evmos.inflation.v1.QueryEpochMintProvisionRequest
 */
export interface QueryEpochMintProvisionRequest {}
/**
 * QueryEpochMintProvisionResponse is the response type for the
 * Query/EpochMintProvision RPC method.
 *
 * @generated from protobuf messages evmos.inflation.v1.QueryEpochMintProvisionResponse
 */
export interface QueryEpochMintProvisionResponse {
  /**
   * epoch_mint_provision is the current minting per epoch provision value.
   *
   * @generated from protobuf field: cosmos.base.v1beta1.DecCoin epoch_mint_provision = 1;
   */
  epochMintProvision?: DecCoin
}
/**
 * QuerySkippedEpochsRequest is the request type for the Query/SkippedEpochs RPC method.
 *
 * @generated from protobuf messages evmos.inflation.v1.QuerySkippedEpochsRequest
 */
export interface QuerySkippedEpochsRequest {}
/**
 * QuerySkippedEpochsResponse is the response type for the Query/SkippedEpochs RPC method.
 *
 * @generated from protobuf messages evmos.inflation.v1.QuerySkippedEpochsResponse
 */
export interface QuerySkippedEpochsResponse {
  /**
   * number of epochs that the inflation module has been disabled.
   *
   * @generated from protobuf field: uint64 skipped_epochs = 1;
   */
  skippedEpochs: string
}
/**
 * QueryTotalSupplyRequest is the request type for the Query/TotalSupply RPC method.
 *
 * @generated from protobuf messages evmos.inflation.v1.QueryTotalSupplyRequest
 */
export interface QueryTotalSupplyRequest {}
/**
 * QueryTotalSupplyResponse is the response type for the Query/TotalSupply RPC method.
 *
 * @generated from protobuf messages evmos.inflation.v1.QueryTotalSupplyResponse
 */
export interface QueryTotalSupplyResponse {
  /**
   * total amount of coins in circulation
   *
   * @generated from protobuf field: cosmos.base.v1beta1.DecCoin total_supply = 1;
   */
  totalSupply?: DecCoin
}
/**
 * QueryInflationRateRequest is the request type for the Query/InflationRate RPC method.
 *
 * @generated from protobuf messages evmos.inflation.v1.QueryInflationRateRequest
 */
export interface QueryInflationRateRequest {}
/**
 * QueryInflationRateResponse is the response type for the Query/InflationRate RPC method.
 *
 * @generated from protobuf messages evmos.inflation.v1.QueryInflationRateResponse
 */
export interface QueryInflationRateResponse {
  /**
   * rate by which the total supply increases within one period
   *
   * @generated from protobuf field: string inflation_rate = 1;
   */
  inflationRate: string
}
/**
 * QueryParamsRequest is the request type for the Query/Params RPC method.
 *
 * @generated from protobuf messages evmos.inflation.v1.QueryParamsRequest
 */
export interface QueryParamsRequest {}
/**
 * QueryParamsResponse is the response type for the Query/Params RPC method.
 *
 * @generated from protobuf messages evmos.inflation.v1.QueryParamsResponse
 */
export interface QueryParamsResponse {
  /**
   * params defines the parameters of the module.
   *
   * @generated from protobuf field: evmos.inflation.v1.Params params = 1;
   */
  params?: Params
}
// @generated messages type with reflection information, may provide speed optimized methods
class QueryPeriodRequest$Type extends MessageType<QueryPeriodRequest> {
  constructor() {
    super('evmos.inflation.v1.QueryPeriodRequest', [])
  }
  create(value?: PartialMessage<QueryPeriodRequest>): QueryPeriodRequest {
    const message = {}
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    })
    if (value !== undefined)
      reflectionMergePartial<QueryPeriodRequest>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: QueryPeriodRequest,
  ): QueryPeriodRequest {
    return target ?? this.create()
  }
  internalBinaryWrite(
    message: QueryPeriodRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    let u = options.writeUnknownFields
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      )
    return writer
  }
}
/**
 * @generated MessageType for protobuf messages evmos.inflation.v1.QueryPeriodRequest
 */
export const QueryPeriodRequest = new QueryPeriodRequest$Type()
// @generated messages type with reflection information, may provide speed optimized methods
class QueryPeriodResponse$Type extends MessageType<QueryPeriodResponse> {
  constructor() {
    super('evmos.inflation.v1.QueryPeriodResponse', [
      { no: 1, name: 'period', kind: 'scalar', T: 4 /*ScalarType.UINT64*/ },
    ])
  }
  create(value?: PartialMessage<QueryPeriodResponse>): QueryPeriodResponse {
    const message = { period: '0' }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    })
    if (value !== undefined)
      reflectionMergePartial<QueryPeriodResponse>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: QueryPeriodResponse,
  ): QueryPeriodResponse {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* uint64 period */ 1:
          message.period = reader.uint64().toString()
          break
        default:
          let u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: QueryPeriodResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* uint64 period = 1; */
    if (message.period !== '0')
      writer.tag(1, WireType.Varint).uint64(message.period)
    let u = options.writeUnknownFields
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      )
    return writer
  }
}
/**
 * @generated MessageType for protobuf messages evmos.inflation.v1.QueryPeriodResponse
 */
export const QueryPeriodResponse = new QueryPeriodResponse$Type()
// @generated messages type with reflection information, may provide speed optimized methods
class QueryEpochMintProvisionRequest$Type extends MessageType<QueryEpochMintProvisionRequest> {
  constructor() {
    super('evmos.inflation.v1.QueryEpochMintProvisionRequest', [])
  }
  create(
    value?: PartialMessage<QueryEpochMintProvisionRequest>,
  ): QueryEpochMintProvisionRequest {
    const message = {}
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    })
    if (value !== undefined)
      reflectionMergePartial<QueryEpochMintProvisionRequest>(
        this,
        message,
        value,
      )
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: QueryEpochMintProvisionRequest,
  ): QueryEpochMintProvisionRequest {
    return target ?? this.create()
  }
  internalBinaryWrite(
    message: QueryEpochMintProvisionRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    let u = options.writeUnknownFields
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      )
    return writer
  }
}
/**
 * @generated MessageType for protobuf messages evmos.inflation.v1.QueryEpochMintProvisionRequest
 */
export const QueryEpochMintProvisionRequest =
  new QueryEpochMintProvisionRequest$Type()
// @generated messages type with reflection information, may provide speed optimized methods
class QueryEpochMintProvisionResponse$Type extends MessageType<QueryEpochMintProvisionResponse> {
  constructor() {
    super('evmos.inflation.v1.QueryEpochMintProvisionResponse', [
      {
        no: 1,
        name: 'epoch_mint_provision',
        kind: 'message',
        T: () => DecCoin,
        options: {
          'gogoproto.nullable': false,
          'gogoproto.castrepeated':
            'github.com/cosmos/cosmos-sdk/types.DecCoins',
        },
      },
    ])
  }
  create(
    value?: PartialMessage<QueryEpochMintProvisionResponse>,
  ): QueryEpochMintProvisionResponse {
    const message = {}
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    })
    if (value !== undefined)
      reflectionMergePartial<QueryEpochMintProvisionResponse>(
        this,
        message,
        value,
      )
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: QueryEpochMintProvisionResponse,
  ): QueryEpochMintProvisionResponse {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* cosmos.base.v1beta1.DecCoin epoch_mint_provision */ 1:
          message.epochMintProvision = DecCoin.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.epochMintProvision,
          )
          break
        default:
          let u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: QueryEpochMintProvisionResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* cosmos.base.v1beta1.DecCoin epoch_mint_provision = 1; */
    if (message.epochMintProvision)
      DecCoin.internalBinaryWrite(
        message.epochMintProvision,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join()
    let u = options.writeUnknownFields
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      )
    return writer
  }
}
/**
 * @generated MessageType for protobuf messages evmos.inflation.v1.QueryEpochMintProvisionResponse
 */
export const QueryEpochMintProvisionResponse =
  new QueryEpochMintProvisionResponse$Type()
// @generated messages type with reflection information, may provide speed optimized methods
class QuerySkippedEpochsRequest$Type extends MessageType<QuerySkippedEpochsRequest> {
  constructor() {
    super('evmos.inflation.v1.QuerySkippedEpochsRequest', [])
  }
  create(
    value?: PartialMessage<QuerySkippedEpochsRequest>,
  ): QuerySkippedEpochsRequest {
    const message = {}
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    })
    if (value !== undefined)
      reflectionMergePartial<QuerySkippedEpochsRequest>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: QuerySkippedEpochsRequest,
  ): QuerySkippedEpochsRequest {
    return target ?? this.create()
  }
  internalBinaryWrite(
    message: QuerySkippedEpochsRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    let u = options.writeUnknownFields
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      )
    return writer
  }
}
/**
 * @generated MessageType for protobuf messages evmos.inflation.v1.QuerySkippedEpochsRequest
 */
export const QuerySkippedEpochsRequest = new QuerySkippedEpochsRequest$Type()
// @generated messages type with reflection information, may provide speed optimized methods
class QuerySkippedEpochsResponse$Type extends MessageType<QuerySkippedEpochsResponse> {
  constructor() {
    super('evmos.inflation.v1.QuerySkippedEpochsResponse', [
      {
        no: 1,
        name: 'skipped_epochs',
        kind: 'scalar',
        T: 4 /*ScalarType.UINT64*/,
      },
    ])
  }
  create(
    value?: PartialMessage<QuerySkippedEpochsResponse>,
  ): QuerySkippedEpochsResponse {
    const message = { skippedEpochs: '0' }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    })
    if (value !== undefined)
      reflectionMergePartial<QuerySkippedEpochsResponse>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: QuerySkippedEpochsResponse,
  ): QuerySkippedEpochsResponse {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* uint64 skipped_epochs */ 1:
          message.skippedEpochs = reader.uint64().toString()
          break
        default:
          let u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: QuerySkippedEpochsResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* uint64 skipped_epochs = 1; */
    if (message.skippedEpochs !== '0')
      writer.tag(1, WireType.Varint).uint64(message.skippedEpochs)
    let u = options.writeUnknownFields
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      )
    return writer
  }
}
/**
 * @generated MessageType for protobuf messages evmos.inflation.v1.QuerySkippedEpochsResponse
 */
export const QuerySkippedEpochsResponse = new QuerySkippedEpochsResponse$Type()
// @generated messages type with reflection information, may provide speed optimized methods
class QueryTotalSupplyRequest$Type extends MessageType<QueryTotalSupplyRequest> {
  constructor() {
    super('evmos.inflation.v1.QueryTotalSupplyRequest', [])
  }
  create(
    value?: PartialMessage<QueryTotalSupplyRequest>,
  ): QueryTotalSupplyRequest {
    const message = {}
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    })
    if (value !== undefined)
      reflectionMergePartial<QueryTotalSupplyRequest>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: QueryTotalSupplyRequest,
  ): QueryTotalSupplyRequest {
    return target ?? this.create()
  }
  internalBinaryWrite(
    message: QueryTotalSupplyRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    let u = options.writeUnknownFields
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      )
    return writer
  }
}
/**
 * @generated MessageType for protobuf messages evmos.inflation.v1.QueryTotalSupplyRequest
 */
export const QueryTotalSupplyRequest = new QueryTotalSupplyRequest$Type()
// @generated messages type with reflection information, may provide speed optimized methods
class QueryTotalSupplyResponse$Type extends MessageType<QueryTotalSupplyResponse> {
  constructor() {
    super('evmos.inflation.v1.QueryTotalSupplyResponse', [
      {
        no: 1,
        name: 'total_supply',
        kind: 'message',
        T: () => DecCoin,
        options: {
          'gogoproto.nullable': false,
          'gogoproto.castrepeated':
            'github.com/cosmos/cosmos-sdk/types.DecCoins',
        },
      },
    ])
  }
  create(
    value?: PartialMessage<QueryTotalSupplyResponse>,
  ): QueryTotalSupplyResponse {
    const message = {}
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    })
    if (value !== undefined)
      reflectionMergePartial<QueryTotalSupplyResponse>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: QueryTotalSupplyResponse,
  ): QueryTotalSupplyResponse {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* cosmos.base.v1beta1.DecCoin total_supply */ 1:
          message.totalSupply = DecCoin.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.totalSupply,
          )
          break
        default:
          let u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: QueryTotalSupplyResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* cosmos.base.v1beta1.DecCoin total_supply = 1; */
    if (message.totalSupply)
      DecCoin.internalBinaryWrite(
        message.totalSupply,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join()
    let u = options.writeUnknownFields
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      )
    return writer
  }
}
/**
 * @generated MessageType for protobuf messages evmos.inflation.v1.QueryTotalSupplyResponse
 */
export const QueryTotalSupplyResponse = new QueryTotalSupplyResponse$Type()
// @generated messages type with reflection information, may provide speed optimized methods
class QueryInflationRateRequest$Type extends MessageType<QueryInflationRateRequest> {
  constructor() {
    super('evmos.inflation.v1.QueryInflationRateRequest', [])
  }
  create(
    value?: PartialMessage<QueryInflationRateRequest>,
  ): QueryInflationRateRequest {
    const message = {}
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    })
    if (value !== undefined)
      reflectionMergePartial<QueryInflationRateRequest>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: QueryInflationRateRequest,
  ): QueryInflationRateRequest {
    return target ?? this.create()
  }
  internalBinaryWrite(
    message: QueryInflationRateRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    let u = options.writeUnknownFields
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      )
    return writer
  }
}
/**
 * @generated MessageType for protobuf messages evmos.inflation.v1.QueryInflationRateRequest
 */
export const QueryInflationRateRequest = new QueryInflationRateRequest$Type()
// @generated messages type with reflection information, may provide speed optimized methods
class QueryInflationRateResponse$Type extends MessageType<QueryInflationRateResponse> {
  constructor() {
    super('evmos.inflation.v1.QueryInflationRateResponse', [
      {
        no: 1,
        name: 'inflation_rate',
        kind: 'scalar',
        T: 9 /*ScalarType.STRING*/,
        options: {
          'gogoproto.nullable': false,
          'gogoproto.customtype': 'github.com/cosmos/cosmos-sdk/types.Dec',
        },
      },
    ])
  }
  create(
    value?: PartialMessage<QueryInflationRateResponse>,
  ): QueryInflationRateResponse {
    const message = { inflationRate: '' }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    })
    if (value !== undefined)
      reflectionMergePartial<QueryInflationRateResponse>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: QueryInflationRateResponse,
  ): QueryInflationRateResponse {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string inflation_rate */ 1:
          message.inflationRate = reader.string()
          break
        default:
          let u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: QueryInflationRateResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string inflation_rate = 1; */
    if (message.inflationRate !== '')
      writer.tag(1, WireType.LengthDelimited).string(message.inflationRate)
    let u = options.writeUnknownFields
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      )
    return writer
  }
}
/**
 * @generated MessageType for protobuf messages evmos.inflation.v1.QueryInflationRateResponse
 */
export const QueryInflationRateResponse = new QueryInflationRateResponse$Type()
// @generated messages type with reflection information, may provide speed optimized methods
class QueryParamsRequest$Type extends MessageType<QueryParamsRequest> {
  constructor() {
    super('evmos.inflation.v1.QueryParamsRequest', [])
  }
  create(value?: PartialMessage<QueryParamsRequest>): QueryParamsRequest {
    const message = {}
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    })
    if (value !== undefined)
      reflectionMergePartial<QueryParamsRequest>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: QueryParamsRequest,
  ): QueryParamsRequest {
    return target ?? this.create()
  }
  internalBinaryWrite(
    message: QueryParamsRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    let u = options.writeUnknownFields
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      )
    return writer
  }
}
/**
 * @generated MessageType for protobuf messages evmos.inflation.v1.QueryParamsRequest
 */
export const QueryParamsRequest = new QueryParamsRequest$Type()
// @generated messages type with reflection information, may provide speed optimized methods
class QueryParamsResponse$Type extends MessageType<QueryParamsResponse> {
  constructor() {
    super('evmos.inflation.v1.QueryParamsResponse', [
      {
        no: 1,
        name: 'params',
        kind: 'message',
        T: () => Params,
        options: { 'gogoproto.nullable': false },
      },
    ])
  }
  create(value?: PartialMessage<QueryParamsResponse>): QueryParamsResponse {
    const message = {}
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    })
    if (value !== undefined)
      reflectionMergePartial<QueryParamsResponse>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: QueryParamsResponse,
  ): QueryParamsResponse {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* evmos.inflation.v1.Params params */ 1:
          message.params = Params.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.params,
          )
          break
        default:
          let u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: QueryParamsResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* evmos.inflation.v1.Params params = 1; */
    if (message.params)
      Params.internalBinaryWrite(
        message.params,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join()
    let u = options.writeUnknownFields
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      )
    return writer
  }
}
/**
 * @generated MessageType for protobuf messages evmos.inflation.v1.QueryParamsResponse
 */
export const QueryParamsResponse = new QueryParamsResponse$Type()
/**
 * @generated ServiceType for protobuf service evmos.inflation.v1.Query
 */
export const Query = new ServiceType('evmos.inflation.v1.Query', [
  {
    name: 'Period',
    options: { 'google.api.http': { get: '/evmos/inflation/v1/period' } },
    I: QueryPeriodRequest,
    O: QueryPeriodResponse,
  },
  {
    name: 'EpochMintProvision',
    options: {
      'google.api.http': { get: '/evmos/inflation/v1/epoch_mint_provision' },
    },
    I: QueryEpochMintProvisionRequest,
    O: QueryEpochMintProvisionResponse,
  },
  {
    name: 'SkippedEpochs',
    options: {
      'google.api.http': { get: '/evmos/inflation/v1/skipped_epochs' },
    },
    I: QuerySkippedEpochsRequest,
    O: QuerySkippedEpochsResponse,
  },
  {
    name: 'TotalSupply',
    options: { 'google.api.http': { get: '/evmos/inflation/v1/total_supply' } },
    I: QueryTotalSupplyRequest,
    O: QueryTotalSupplyResponse,
  },
  {
    name: 'InflationRate',
    options: {
      'google.api.http': { get: '/evmos/inflation/v1/inflation_rate' },
    },
    I: QueryInflationRateRequest,
    O: QueryInflationRateResponse,
  },
  {
    name: 'Params',
    options: { 'google.api.http': { get: '/evmos/inflation/v1/params' } },
    I: QueryParamsRequest,
    O: QueryParamsResponse,
  },
])
