// @ts-nocheck
// @generated by protobuf-ts 2.5.0 with parameter long_type_string
// @generated from protobuf file "evmos/inflation/v1/inflation.proto" (package "evmos.inflation.v1", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from '@protobuf-ts/runtime'
import type { IBinaryWriter } from '@protobuf-ts/runtime'
import { WireType } from '@protobuf-ts/runtime'
import type { BinaryReadOptions } from '@protobuf-ts/runtime'
import type { IBinaryReader } from '@protobuf-ts/runtime'
import { UnknownFieldHandler } from '@protobuf-ts/runtime'
import type { PartialMessage } from '@protobuf-ts/runtime'
import { reflectionMergePartial } from '@protobuf-ts/runtime'
import { MESSAGE_TYPE } from '@protobuf-ts/runtime'
import { MessageType } from '@protobuf-ts/runtime'
/**
 * InflationDistribution defines the distribution in which inflation is
 * allocated through minting on each epoch (staking, incentives, community). It
 * excludes the team vesting distribution, as this is minted once at genesis.
 * The initial InflationDistribution can be calculated from the Evmvos Token
 * Model like this:
 * mintDistribution1 = distribution1 / (1 - teamVestingDistribution)
 * 0.5333333         = 40%           / (1 - 25%)
 *
 * @generated from protobuf messages evmos.inflation.v1.InflationDistribution
 */
export interface InflationDistribution {
  /**
   * staking_rewards defines the proportion of the minted minted_denom that is
   * to be allocated as staking rewards
   *
   * @generated from protobuf field: string staking_rewards = 1;
   */
  stakingRewards: string
  /**
   * usage_incentives defines the proportion of the minted minted_denom that is
   * to be allocated to the incentives module address
   *
   * @generated from protobuf field: string usage_incentives = 2;
   */
  usageIncentives: string
  /**
   * community_pool defines the proportion of the minted minted_denom that is to
   * be allocated to the community pool
   *
   * @generated from protobuf field: string community_pool = 3;
   */
  communityPool: string
}
/**
 * ExponentialCalculation holds factors to calculate exponential inflation on
 * each period. Calculation reference:
 * periodProvision = exponentialDecay       *  bondingIncentive
 * f(x)            = (a * (1 - r) ^ x + c)  *  (1 + max_variance - bondedRatio *
 * (max_variance / bonding_target))
 *
 * @generated from protobuf messages evmos.inflation.v1.ExponentialCalculation
 */
export interface ExponentialCalculation {
  /**
   * initial value
   *
   * @generated from protobuf field: string a = 1;
   */
  a: string
  /**
   * reduction factor
   *
   * @generated from protobuf field: string r = 2;
   */
  r: string
  /**
   * long term inflation
   *
   * @generated from protobuf field: string c = 3;
   */
  c: string
  /**
   * bonding target
   *
   * @generated from protobuf field: string bonding_target = 4;
   */
  bondingTarget: string
  /**
   * max variance
   *
   * @generated from protobuf field: string max_variance = 5;
   */
  maxVariance: string
}
// @generated messages type with reflection information, may provide speed optimized methods
class InflationDistribution$Type extends MessageType<InflationDistribution> {
  constructor() {
    super('evmos.inflation.v1.InflationDistribution', [
      {
        no: 1,
        name: 'staking_rewards',
        kind: 'scalar',
        T: 9 /*ScalarType.STRING*/,
        options: {
          'gogoproto.nullable': false,
          'gogoproto.customtype': 'github.com/cosmos/cosmos-sdk/types.Dec',
        },
      },
      {
        no: 2,
        name: 'usage_incentives',
        kind: 'scalar',
        T: 9 /*ScalarType.STRING*/,
        options: {
          'gogoproto.nullable': false,
          'gogoproto.customtype': 'github.com/cosmos/cosmos-sdk/types.Dec',
        },
      },
      {
        no: 3,
        name: 'community_pool',
        kind: 'scalar',
        T: 9 /*ScalarType.STRING*/,
        options: {
          'gogoproto.nullable': false,
          'gogoproto.customtype': 'github.com/cosmos/cosmos-sdk/types.Dec',
        },
      },
    ])
  }
  create(value?: PartialMessage<InflationDistribution>): InflationDistribution {
    const message = {
      stakingRewards: '',
      usageIncentives: '',
      communityPool: '',
    }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    })
    if (value !== undefined)
      reflectionMergePartial<InflationDistribution>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: InflationDistribution,
  ): InflationDistribution {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string staking_rewards */ 1:
          message.stakingRewards = reader.string()
          break
        case /* string usage_incentives */ 2:
          message.usageIncentives = reader.string()
          break
        case /* string community_pool */ 3:
          message.communityPool = reader.string()
          break
        default:
          let u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: InflationDistribution,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string staking_rewards = 1; */
    if (message.stakingRewards !== '')
      writer.tag(1, WireType.LengthDelimited).string(message.stakingRewards)
    /* string usage_incentives = 2; */
    if (message.usageIncentives !== '')
      writer.tag(2, WireType.LengthDelimited).string(message.usageIncentives)
    /* string community_pool = 3; */
    if (message.communityPool !== '')
      writer.tag(3, WireType.LengthDelimited).string(message.communityPool)
    let u = options.writeUnknownFields
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      )
    return writer
  }
}
/**
 * @generated MessageType for protobuf messages evmos.inflation.v1.InflationDistribution
 */
export const InflationDistribution = new InflationDistribution$Type()
// @generated messages type with reflection information, may provide speed optimized methods
class ExponentialCalculation$Type extends MessageType<ExponentialCalculation> {
  constructor() {
    super('evmos.inflation.v1.ExponentialCalculation', [
      {
        no: 1,
        name: 'a',
        kind: 'scalar',
        T: 9 /*ScalarType.STRING*/,
        options: {
          'gogoproto.nullable': false,
          'gogoproto.customtype': 'github.com/cosmos/cosmos-sdk/types.Dec',
        },
      },
      {
        no: 2,
        name: 'r',
        kind: 'scalar',
        T: 9 /*ScalarType.STRING*/,
        options: {
          'gogoproto.nullable': false,
          'gogoproto.customtype': 'github.com/cosmos/cosmos-sdk/types.Dec',
        },
      },
      {
        no: 3,
        name: 'c',
        kind: 'scalar',
        T: 9 /*ScalarType.STRING*/,
        options: {
          'gogoproto.nullable': false,
          'gogoproto.customtype': 'github.com/cosmos/cosmos-sdk/types.Dec',
        },
      },
      {
        no: 4,
        name: 'bonding_target',
        kind: 'scalar',
        T: 9 /*ScalarType.STRING*/,
        options: {
          'gogoproto.nullable': false,
          'gogoproto.customtype': 'github.com/cosmos/cosmos-sdk/types.Dec',
        },
      },
      {
        no: 5,
        name: 'max_variance',
        kind: 'scalar',
        T: 9 /*ScalarType.STRING*/,
        options: {
          'gogoproto.nullable': false,
          'gogoproto.customtype': 'github.com/cosmos/cosmos-sdk/types.Dec',
        },
      },
    ])
  }
  create(
    value?: PartialMessage<ExponentialCalculation>,
  ): ExponentialCalculation {
    const message = { a: '', r: '', c: '', bondingTarget: '', maxVariance: '' }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    })
    if (value !== undefined)
      reflectionMergePartial<ExponentialCalculation>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ExponentialCalculation,
  ): ExponentialCalculation {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string a */ 1:
          message.a = reader.string()
          break
        case /* string r */ 2:
          message.r = reader.string()
          break
        case /* string c */ 3:
          message.c = reader.string()
          break
        case /* string bonding_target */ 4:
          message.bondingTarget = reader.string()
          break
        case /* string max_variance */ 5:
          message.maxVariance = reader.string()
          break
        default:
          let u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: ExponentialCalculation,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string a = 1; */
    if (message.a !== '')
      writer.tag(1, WireType.LengthDelimited).string(message.a)
    /* string r = 2; */
    if (message.r !== '')
      writer.tag(2, WireType.LengthDelimited).string(message.r)
    /* string c = 3; */
    if (message.c !== '')
      writer.tag(3, WireType.LengthDelimited).string(message.c)
    /* string bonding_target = 4; */
    if (message.bondingTarget !== '')
      writer.tag(4, WireType.LengthDelimited).string(message.bondingTarget)
    /* string max_variance = 5; */
    if (message.maxVariance !== '')
      writer.tag(5, WireType.LengthDelimited).string(message.maxVariance)
    let u = options.writeUnknownFields
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      )
    return writer
  }
}
/**
 * @generated MessageType for protobuf messages evmos.inflation.v1.ExponentialCalculation
 */
export const ExponentialCalculation = new ExponentialCalculation$Type()
